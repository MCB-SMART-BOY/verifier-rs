# ç¬¬å…­ç« ï¼šéªŒè¯æµç¨‹è¯¦è§£ | Chapter 6: Verification Flow Deep Dive

```
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   "éªŒè¯æ˜¯ä¸€åœºå¯¹ç¨‹åºæ‰€æœ‰å¯èƒ½è¡Œä¸ºçš„ç©·ä¸¾å¼æ¢ç´¢"                                      |
|   "Verification is an exhaustive exploration of all possible program             |
|    behaviors"                                                                     |
|                                                                                   |
|   ç†è§£éªŒè¯æµç¨‹ï¼Œå°±æ˜¯ç†è§£éªŒè¯å™¨çš„"æ€è€ƒæ–¹å¼"                                        |
|   Understanding the verification flow means understanding how the                |
|   verifier "thinks"                                                               |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

## ğŸ¯ æœ¬ç« ç›®æ ‡ | Chapter Goals

å­¦å®Œè¿™ç« ï¼Œä½ ä¼šç†è§£ï¼š
- éªŒè¯å™¨çš„å®Œæ•´å·¥ä½œæµç¨‹ (Complete verification workflow)
- æŠ½è±¡è§£é‡Šå¦‚ä½•æ¨¡æ‹Ÿç¨‹åºæ‰§è¡Œ (How abstract interpretation simulates execution)
- åˆ†æ”¯å¦‚ä½•äº§ç”Ÿå¤šä¸ªéªŒè¯è·¯å¾„ (How branches create multiple verification paths)
- çŠ¶æ€å‰ªæå¦‚ä½•é¿å…è·¯å¾„çˆ†ç‚¸ (How state pruning prevents path explosion)
- éªŒè¯æˆåŠŸå’Œå¤±è´¥çš„æ¡ä»¶ (Conditions for success and failure)

---

## ğŸ“Š éªŒè¯æµç¨‹æ€»è§ˆ | Verification Flow Overview

```
+-----------------------------------------------------------------------------------+
|                        éªŒè¯æµç¨‹å®Œæ•´æ¶æ„                                        |
|                   Complete Verification Architecture                          |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                         è¾“å…¥é˜¶æ®µ | Input Phase                          | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |   |   BPF å­—èŠ‚ç   | ---> |   æŒ‡ä»¤åæ±‡ç¼–  | ---> |  CFG æ„å»º     |       | |
|   |   |   Bytecode    |      |   Disassembly |      |  CFG Build    |       | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |         |                       |                       |               | |
|   |         v                       v                       v               | |
|   |   64ä½æŒ‡ä»¤åºåˆ—            BpfInsn æ•°ç»„             åŸºæœ¬å— + è¾¹          | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                    |                                          |
|                                    v                                          |
|   +-------------------------------------------------------------------------+ |
|   |                       åˆ†æé˜¶æ®µ | Analysis Phase                         | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |   |   å¾ªç¯æ£€æµ‹    | ---> |   SCC åˆ†æ    | ---> |  å­ç¨‹åºè¯†åˆ«   |       | |
|   |   |   Loop Check  |      |   SCC Build   |      |  Subprog ID   |       | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                    |                                          |
|                                    v                                          |
|   +-------------------------------------------------------------------------+ |
|   |                       éªŒè¯é˜¶æ®µ | Verification Phase                     | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |         +----------------------------------------------------+          | |
|   |         |                                                    |          | |
|   |         v                                                    |          | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |   |  çŠ¶æ€åˆå§‹åŒ–   | ---> |   æŒ‡ä»¤æ¨¡æ‹Ÿ    | ---> |   çŠ¶æ€æ›´æ–°    |       | |
|   |   |  State Init   |      |   Simulate    |      |  State Update |       | |
|   |   +---------------+      +---------------+      +-------+-------+       | |
|   |                                 ^                        |              | |
|   |                                 |                        v              | |
|   |                          +------+-------+         +---------------+     | |
|   |                          |   å·¥ä½œåˆ—è¡¨   | <------ |   çŠ¶æ€å‰ªæ    |     | |
|   |                          |   Worklist   |         |   Pruning     |     | |
|   |                          +--------------+         +---------------+     | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                    |                                          |
|                                    v                                          |
|   +-------------------------------------------------------------------------+ |
|   |                       è¾“å‡ºé˜¶æ®µ | Output Phase                           | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |   |   éªŒè¯æˆåŠŸ    |  æˆ–  |   éªŒè¯å¤±è´¥    |  æˆ–  |   èµ„æºè¶…é™    |       | |
|   |   |   Success âœ“   |      |   Failure âœ—   |      |   Limit Hit   |       | |
|   |   +---------------+      +---------------+      +---------------+       | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## ğŸ” ç¬¬ä¸€é˜¶æ®µï¼šç¨‹åºåŠ è½½ä¸åæ±‡ç¼– | Phase 1: Program Loading and Disassembly

### 1.1 BPF å­—èŠ‚ç ç»“æ„ | BPF Bytecode Structure

```
+-----------------------------------------------------------------------------------+
|                          BPF æŒ‡ä»¤ç¼–ç æ ¼å¼                                      |
|                       BPF Instruction Encoding                                |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   æ¯æ¡ BPF æŒ‡ä»¤å  64 ä½ (8 å­—èŠ‚):                                             |
|   Each BPF instruction is 64 bits (8 bytes):                                  |
|                                                                                   |
|   +---------+---------+---------+---------+---------------------------------+ |
|   |  Byte 0 |  Byte 1 | Byte 2-3| Byte 4-7|                                 | |
|   +---------+---------+---------+---------+                                 | |
|   | opcode  |dst|src  |  offset |   imm   |                                 | |
|   | æ“ä½œç   |ç›®|æº   |  åç§»   | ç«‹å³æ•°  |                                 | |
|   | 8 bits  |4b|4b   | 16 bits | 32 bits |                                 | |
|   +---------+---------+---------+---------+---------------------------------+ |
|                                                                                   |
|   ç¤ºä¾‹: add r1, 10                                                            |
|   Example: add r1, 10                                                         |
|                                                                                   |
|   +---------+---------+---------+---------------------------------------------+|
|   |  0x07   |  0x01   |  0x00   |              0x0000000A                     ||
|   +---------+---------+---------+---------------------------------------------+|
|   |BPF_ADD  | dst=1   |offset=0 |            imm=10                           ||
|   |BPF_K    | src=0   |         |                                             ||
|   +---------+---------+---------+---------------------------------------------+|
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 1.2 åæ±‡ç¼–ä»£ç  | Disassembly Code

```rust
// æ–‡ä»¶ä½ç½®: crates/bpf-verifier-core/src/core/disasm.rs

/// åæ±‡ç¼–å•æ¡æŒ‡ä»¤
/// Disassemble a single instruction
pub fn disasm_insn(bytes: &[u8]) -> Result<BpfInsn, DisasmError> {
    if bytes.len() < 8 {
        return Err(DisasmError::InsufficientBytes);
    }
    
    // è§£æå„å­—æ®µ
    let opcode = bytes[0];
    let regs = bytes[1];
    let dst_reg = regs & 0x0f;        // ä½ 4 ä½: ç›®æ ‡å¯„å­˜å™¨
    let src_reg = (regs >> 4) & 0x0f; // é«˜ 4 ä½: æºå¯„å­˜å™¨
    let offset = i16::from_le_bytes([bytes[2], bytes[3]]);
    let imm = i32::from_le_bytes([bytes[4], bytes[5], bytes[6], bytes[7]]);
    
    Ok(BpfInsn {
        code: opcode,
        dst_reg,
        src_reg,
        off: offset,
        imm,
    })
}
```

### 1.3 ç‰¹æ®ŠæŒ‡ä»¤ï¼š64ä½ç«‹å³æ•° | Special Instruction: 64-bit Immediate

```
+-----------------------------------------------------------------------------------+
|                          LD_IMM64 åŒæŒ‡ä»¤ç¼–ç                                    |
|                     LD_IMM64 Double Instruction Encoding                      |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   åŠ è½½ 64 ä½ç«‹å³æ•°éœ€è¦ä¸¤æ¡æŒ‡ä»¤:                                               |
|   Loading a 64-bit immediate requires two instructions:                       |
|                                                                                   |
|   æŒ‡ä»¤ N:                                                                     |
|   +---------+---------+---------+---------------------------------------------+|
|   |  0x18   |dst|src  | offset  |           imm_low (ä½32ä½)                  ||
|   | LD_IMM64|         |         |           imm_low (low 32)                  ||
|   +---------+---------+---------+---------------------------------------------+|
|                                                                                   |
|   æŒ‡ä»¤ N+1 (ä¼ªæŒ‡ä»¤):                                                          |
|   +---------+---------+---------+---------------------------------------------+|
|   |  0x00   |  0x00   |  0x00   |           imm_high (é«˜32ä½)                 ||
|   | (unused)|         |         |           imm_high (high 32)                ||
|   +---------+---------+---------+---------------------------------------------+|
|                                                                                   |
|   å®Œæ•´å€¼ = (imm_high << 32) | imm_low                                         |
|   Full value = (imm_high << 32) | imm_low                                     |
|                                                                                   |
|   ç¤ºä¾‹: r1 = 0x123456789ABCDEF0                                               |
|   Example: r1 = 0x123456789ABCDEF0                                            |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   | æŒ‡ä»¤ 0: 0x18 0x01 0x00 0x00   0x9ABCDEF0                                | |
|   |         LD_IMM64 dst=r1       imm_low                                   | |
|   +-------------------------------------------------------------------------+ |
|   | æŒ‡ä»¤ 1: 0x00 0x00 0x00 0x00   0x12345678                                | |
|   |         (ä¼ªæŒ‡ä»¤)              imm_high                                  | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## ğŸ“ˆ ç¬¬äºŒé˜¶æ®µï¼šæ§åˆ¶æµå›¾æ„å»º | Phase 2: Control Flow Graph Construction

### 2.1 åŸºæœ¬å—çš„æ¦‚å¿µ | Concept of Basic Block

```
+-----------------------------------------------------------------------------------+
|                           åŸºæœ¬å—å®šä¹‰                                           |
|                       Basic Block Definition                                  |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   åŸºæœ¬å—æ˜¯ä¸€ç»„é¡ºåºæ‰§è¡Œçš„æŒ‡ä»¤ï¼Œæ»¡è¶³:                                           |
|   A basic block is a sequence of instructions that:                          |
|                                                                                   |
|   1. åªèƒ½ä»ç¬¬ä¸€æ¡æŒ‡ä»¤è¿›å…¥ | Can only be entered at the first instruction      |
|   2. åªèƒ½ä»æœ€åä¸€æ¡æŒ‡ä»¤ç¦»å¼€ | Can only be exited at the last instruction      |
|   3. ä¸­é—´æ²¡æœ‰åˆ†æ”¯æˆ–è·³è½¬ç›®æ ‡ | No branches or jump targets in between          |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                          åŸºæœ¬å—è¾¹ç•Œ                                      | |
|   |                     Basic Block Boundaries                              | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   å¼€å§‹æ–°å— | Start New Block:                                           | |
|   |   +----------------------------------------------------------------+    | |
|   |   | â€¢ ç¨‹åºå…¥å£ç‚¹ (æŒ‡ä»¤ 0)                                          |    | |
|   |   |   Program entry point (instruction 0)                          |    | |
|   |   | â€¢ è·³è½¬æŒ‡ä»¤çš„ç›®æ ‡åœ°å€                                           |    | |
|   |   |   Target address of jump instructions                          |    | |
|   |   | â€¢ è·³è½¬æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ (fall-through)                          |    | |
|   |   |   Next instruction after jump (fall-through)                   |    | |
|   |   +----------------------------------------------------------------+    | |
|   |                                                                         | |
|   |   ç»“æŸå½“å‰å— | End Current Block:                                       | |
|   |   +----------------------------------------------------------------+    | |
|   |   | â€¢ æ— æ¡ä»¶è·³è½¬ (JA)                                              |    | |
|   |   |   Unconditional jump (JA)                                      |    | |
|   |   | â€¢ æ¡ä»¶è·³è½¬ (JEQ, JGT, JLT, ...)                                |    | |
|   |   |   Conditional jump (JEQ, JGT, JLT, ...)                        |    | |
|   |   | â€¢ ç¨‹åºé€€å‡º (EXIT)                                              |    | |
|   |   |   Program exit (EXIT)                                          |    | |
|   |   | â€¢ å‡½æ•°è°ƒç”¨è¿”å›                                                 |    | |
|   |   |   Function call return                                         |    | |
|   |   +----------------------------------------------------------------+    | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 2.2 CFG æ„å»ºç¤ºä¾‹ | CFG Construction Example

```
+-----------------------------------------------------------------------------------+
|                          CFG æ„å»ºç¤ºä¾‹                                          |
|                    CFG Construction Example                                   |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   æºç¨‹åº | Source Program:                                                    |
|   +-------------------------------------------------------------------------+ |
|   |  0: r0 = 0                  // åˆå§‹åŒ–è¿”å›å€¼                             | |
|   |  1: if r1 > 10 goto 4       // æ¡ä»¶è·³è½¬                                 | |
|   |  2: r0 = 1                  // è®¾ç½®è¿”å›å€¼ 1                             | |
|   |  3: goto 5                  // æ— æ¡ä»¶è·³è½¬                               | |
|   |  4: r0 = 2                  // è®¾ç½®è¿”å›å€¼ 2                             | |
|   |  5: exit                    // ç¨‹åºé€€å‡º                                 | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   åŸºæœ¬å—åˆ’åˆ† | Basic Block Division:                                          |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   Block 0: æŒ‡ä»¤ 0-1         Block 1: æŒ‡ä»¤ 2-3                           | |
|   |   +-------------------+     +-------------------+                       | |
|   |   | 0: r0 = 0         |     | 2: r0 = 1         |                       | |
|   |   | 1: if r1>10 goto 4|     | 3: goto 5         |                       | |
|   |   +-------------------+     +-------------------+                       | |
|   |                                                                         | |
|   |   Block 2: æŒ‡ä»¤ 4           Block 3: æŒ‡ä»¤ 5                             | |
|   |   +-------------------+     +-------------------+                       | |
|   |   | 4: r0 = 2         |     | 5: exit           |                       | |
|   |   +-------------------+     +-------------------+                       | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   æ„å»ºçš„ CFG | Constructed CFG:                                               |
|                                                                                   |
|                    +---------------------+                                    |
|                    |      Block 0        |                                    |
|                    |  0: r0 = 0          |                                    |
|                    |  1: if r1>10 goto 4 |                                    |
|                    +----------+----------+                                    |
|                               |                                               |
|              +----------------+----------------+                              |
|              |                |                |                              |
|              | r1 <= 10       |                | r1 > 10                      |
|              | (fall-through) |                | (jump)                       |
|              v                                 v                              |
|   +---------------------+           +---------------------+                   |
|   |      Block 1        |           |      Block 2        |                   |
|   |  2: r0 = 1          |           |  4: r0 = 2          |                   |
|   |  3: goto 5          |           +----------+----------+                   |
|   +----------+----------+                      |                              |
|              |                                 |                              |
|              | (jump)                          | (fall-through)               |
|              |                                 |                              |
|              +----------------+----------------+                              |
|                               |                                               |
|                               v                                               |
|                    +---------------------+                                    |
|                    |      Block 3        |                                    |
|                    |  5: exit            |                                    |
|                    +---------------------+                                    |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 2.3 CFG æ•°æ®ç»“æ„ | CFG Data Structure

```rust
// æ–‡ä»¶ä½ç½®: crates/bpf-verifier-core/src/analysis/cfg.rs

/// æ§åˆ¶æµå›¾
/// Control Flow Graph
pub struct Cfg {
    /// åŸºæœ¬å—æ•°ç»„
    pub blocks: Vec<BasicBlock>,
    /// å…¥å£å—ç´¢å¼•
    pub entry: usize,
}

/// åŸºæœ¬å—
/// Basic Block
pub struct BasicBlock {
    /// èµ·å§‹æŒ‡ä»¤ç´¢å¼•
    pub start: usize,
    /// ç»“æŸæŒ‡ä»¤ç´¢å¼•ï¼ˆåŒ…å«ï¼‰
    pub end: usize,
    /// åç»§å—åˆ—è¡¨
    pub successors: Vec<BlockEdge>,
    /// å‰é©±å—åˆ—è¡¨
    pub predecessors: Vec<usize>,
}

/// å—ä¹‹é—´çš„è¾¹
/// Edge between blocks
pub struct BlockEdge {
    /// ç›®æ ‡å—ç´¢å¼•
    pub target: usize,
    /// è¾¹çš„ç±»å‹
    pub edge_type: EdgeType,
}

/// è¾¹çš„ç±»å‹
/// Edge type
pub enum EdgeType {
    /// Fall-throughï¼ˆé¡ºåºæ‰§è¡Œï¼‰
    FallThrough,
    /// æ¡ä»¶è·³è½¬ - æ¡ä»¶ä¸ºçœŸ
    ConditionalTrue,
    /// æ¡ä»¶è·³è½¬ - æ¡ä»¶ä¸ºå‡
    ConditionalFalse,
    /// æ— æ¡ä»¶è·³è½¬
    Unconditional,
}
```

---

## ğŸ”„ ç¬¬ä¸‰é˜¶æ®µï¼šä¸»éªŒè¯å¾ªç¯ | Phase 3: Main Verification Loop

### 3.1 å·¥ä½œåˆ—è¡¨ç®—æ³• | Worklist Algorithm

```
+-----------------------------------------------------------------------------------+
|                          å·¥ä½œåˆ—è¡¨ç®—æ³•                                          |
|                       Worklist Algorithm                                      |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   éªŒè¯å™¨ä½¿ç”¨å·¥ä½œåˆ—è¡¨ç®—æ³•éå†æ‰€æœ‰ç¨‹åºè·¯å¾„:                                     |
|   The verifier uses a worklist algorithm to traverse all program paths:       |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   åˆå§‹åŒ– | Initialize:                                                  | |
|   |   +-----------------------------------------------------------------+   | |
|   |   |  worklist = [ (å…¥å£çŠ¶æ€, æŒ‡ä»¤0) ]                               |   | |
|   |   |  worklist = [ (initial_state, instruction 0) ]                  |   | |
|   |   +-----------------------------------------------------------------+   | |
|   |                                                                         | |
|   |   ä¸»å¾ªç¯ | Main Loop:                                                   | |
|   |   +-----------------------------------------------------------------+   | |
|   |   |  while worklist éç©º:                                           |   | |
|   |   |      (state, insn_idx) = worklist.pop()                         |   | |
|   |   |                                                                 |   | |
|   |   |      // å°è¯•å‰ªæ                                                |   | |
|   |   |      if can_prune(state, insn_idx):                             |   | |
|   |   |          continue                                               |   | |
|   |   |                                                                 |   | |
|   |   |      // æ¨¡æ‹Ÿæ‰§è¡ŒæŒ‡ä»¤                                            |   | |
|   |   |      result = simulate(state, insn_idx)                         |   | |
|   |   |                                                                 |   | |
|   |   |      // æ ¹æ®ç»“æœæ·»åŠ åç»­çŠ¶æ€                                    |   | |
|   |   |      match result:                                              |   | |
|   |   |          Continue(new_state) => worklist.push(new_state)        |   | |
|   |   |          Branch(s1, s2) => { worklist.push(s1); push(s2) }     |   | |
|   |   |          Exit => { /* è·¯å¾„å®Œæˆ */ }                             |   | |
|   |   |          Error => return Err(...)                               |   | |
|   |   +-----------------------------------------------------------------+   | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   å·¥ä½œåˆ—è¡¨çŠ¶æ€å˜åŒ–ç¤ºä¾‹:                                                       |
|   Worklist state changes example:                                             |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   Step 1: worklist = [S0@insn0]                                         | |
|   |           å¤„ç† S0@insn0, ç»§ç»­åˆ° insn1                                   | |
|   |                                                                         | |
|   |   Step 2: worklist = [S1@insn1]                                         | |
|   |           å¤„ç† S1@insn1, æ¡ä»¶åˆ†æ”¯äº§ç”Ÿä¸¤ä¸ªçŠ¶æ€                           | |
|   |                                                                         | |
|   |   Step 3: worklist = [S2a@insn2, S2b@insn4]                             | |
|   |           å¤„ç† S2a@insn2, ç»§ç»­åˆ° insn3                                  | |
|   |                                                                         | |
|   |   Step 4: worklist = [S3@insn3, S2b@insn4]                              | |
|   |           å¤„ç† S3@insn3, è·³è½¬åˆ° insn5                                   | |
|   |                                                                         | |
|   |   Step 5: worklist = [S4@insn5, S2b@insn4]                              | |
|   |           å¤„ç† S4@insn5 (exit), è·¯å¾„å®Œæˆ                                | |
|   |                                                                         | |
|   |   Step 6: worklist = [S2b@insn4]                                        | |
|   |           å¤„ç† S2b@insn4, ç»§ç»­åˆ° insn5                                  | |
|   |                                                                         | |
|   |   Step 7: worklist = [S5@insn5]                                         | |
|   |           å¤„ç† S5@insn5 (exit), è·¯å¾„å®Œæˆ                                | |
|   |                                                                         | |
|   |   Step 8: worklist = []                                                 | |
|   |           éªŒè¯å®Œæˆï¼                                                    | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 3.2 ä¸»éªŒè¯å¾ªç¯ä»£ç  | Main Verification Loop Code

```rust
// æ–‡ä»¶ä½ç½®: crates/bpf-verifier-core/src/verifier/main_loop.rs

/// ä¸»éªŒè¯å¾ªç¯
/// Main verification loop
pub fn do_check<P: PlatformSpec>(env: &mut GenericVerifierEnv<P>) -> Result<()> {
    // åˆå§‹åŒ–å·¥ä½œåˆ—è¡¨
    env.init_worklist()?;
    
    // ä¸»å¾ªç¯
    while let Some((state, insn_idx)) = env.pop_state() {
        // æ›´æ–°å½“å‰çŠ¶æ€
        env.cur_state = state;
        env.insn_idx = insn_idx;
        
        // æ£€æŸ¥æŒ‡ä»¤æ•°é™åˆ¶
        env.insn_processed += 1;
        if env.insn_processed > env.insn_limit {
            return Err(Error::TooManyInstructions);
        }
        
        // å°è¯•çŠ¶æ€å‰ªæ
        if env.try_prune()? {
            continue;
        }
        
        // è·å–å½“å‰æŒ‡ä»¤
        let insn = env.insns[insn_idx];
        
        // æ¨¡æ‹Ÿæ‰§è¡ŒæŒ‡ä»¤
        let result = check_insn(env, &insn)?;
        
        // å¤„ç†æ‰§è¡Œç»“æœ
        match result {
            InsnResult::Continue => {
                // ç»§ç»­ä¸‹ä¸€æ¡æŒ‡ä»¤
                env.push_state(env.cur_state.clone(), insn_idx + 1);
            }
            InsnResult::Jump(target) => {
                // æ— æ¡ä»¶è·³è½¬
                env.push_state(env.cur_state.clone(), target);
            }
            InsnResult::Branch { true_state, false_state, target } => {
                // æ¡ä»¶åˆ†æ”¯
                env.push_state(true_state, target);
                env.push_state(false_state, insn_idx + 1);
            }
            InsnResult::Exit => {
                // ç¨‹åºé€€å‡ºï¼Œæ£€æŸ¥èµ„æºé‡Šæ”¾
                check_exit(env)?;
            }
            InsnResult::Call { target } => {
                // å‡½æ•°è°ƒç”¨
                handle_call(env, target)?;
            }
        }
    }
    
    Ok(())
}
```

---

## ğŸ­ ç¬¬å››é˜¶æ®µï¼šæŒ‡ä»¤æ¨¡æ‹Ÿ | Phase 4: Instruction Simulation

### 4.1 æŒ‡ä»¤åˆ†ç±»å¤„ç† | Instruction Type Processing

```
+-----------------------------------------------------------------------------------+
|                          æŒ‡ä»¤æ¨¡æ‹Ÿåˆ†ç±»                                          |
|                   Instruction Simulation Categories                           |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                    ALU æŒ‡ä»¤ | ALU Instructions                          | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   +-------------+      +-------------+      +-------------+             | |
|   |   |  æºæ“ä½œæ•°   |      |   è¿ç®—é€»è¾‘  |      |  ç›®æ ‡ç»“æœ   |             | |
|   |   | src state   | ---> |  operation  | ---> | dst state   |             | |
|   |   +-------------+      +-------------+      +-------------+             | |
|   |                                                                         | |
|   |   ç¤ºä¾‹: add r0, r1                                                      | |
|   |   +-----------------------------------------------------------------+   | |
|   |   | è¾“å…¥: r0 âˆˆ [10, 20], r1 âˆˆ [5, 15]                               |   | |
|   |   | è®¡ç®—: umin = 10+5=15, umax = 20+15=35                           |   | |
|   |   | è¾“å‡º: r0 âˆˆ [15, 35]                                             |   | |
|   |   +-----------------------------------------------------------------+   | |
|   |                                                                         | |
|   |   æ”¯æŒçš„ ALU æ“ä½œ:                                                      | |
|   |   â€¢ ADD (åŠ æ³•)  â€¢ SUB (å‡æ³•)  â€¢ MUL (ä¹˜æ³•)  â€¢ DIV (é™¤æ³•)               | |
|   |   â€¢ AND (ä¸)    â€¢ OR (æˆ–)     â€¢ XOR (å¼‚æˆ–)  â€¢ LSH (å·¦ç§»)               | |
|   |   â€¢ RSH (å³ç§»)  â€¢ ARSH (ç®—æœ¯å³ç§»)  â€¢ NEG (å–å)  â€¢ MOD (å–æ¨¡)          | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                   JMP æŒ‡ä»¤ | JMP Instructions                           | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   æ¡ä»¶è·³è½¬äº§ç”ŸçŠ¶æ€åˆ†è£‚:                                                 | |
|   |   Conditional jumps cause state splitting:                              | |
|   |                                                                         | |
|   |              åŸçŠ¶æ€: r1 âˆˆ [0, 100]                                      | |
|   |                         |                                               | |
|   |              jgt r1, 50, target                                         | |
|   |                         |                                               | |
|   |              +----------+----------+                                    | |
|   |              v                     v                                    | |
|   |   +---------------------+  +---------------------+                      | |
|   |   | True åˆ†æ”¯ (jump)    |  | False åˆ†æ”¯ (fall)   |                      | |
|   |   | r1 âˆˆ [51, 100]      |  | r1 âˆˆ [0, 50]        |                      | |
|   |   |                     |  |                     |                      | |
|   |   | è·³è½¬åˆ° target       |  | ç»§ç»­ä¸‹ä¸€æ¡æŒ‡ä»¤      |                      | |
|   |   +---------------------+  +---------------------+                      | |
|   |                                                                         | |
|   |   æ”¯æŒçš„æ¡ä»¶:                                                           | |
|   |   â€¢ JEQ (ç­‰äº)  â€¢ JNE (ä¸ç­‰äº)  â€¢ JGT (å¤§äº)  â€¢ JGE (å¤§äºç­‰äº)          | |
|   |   â€¢ JLT (å°äº)  â€¢ JLE (å°äºç­‰äº) â€¢ JSET (ä½æµ‹è¯•) â€¢ JSGT (æœ‰ç¬¦å·å¤§äº)    | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                   MEM æŒ‡ä»¤ | MEM Instructions                           | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   å†…å­˜è®¿é—®æ£€æŸ¥æµç¨‹:                                                     | |
|   |   Memory access check flow:                                             | |
|   |                                                                         | |
|   |   +---------+   +---------+   +---------+   +---------+   +---------+   | |
|   |   | æ£€æŸ¥    |   | æ£€æŸ¥    |   | æ£€æŸ¥    |   | æ£€æŸ¥    |   | æ‰§è¡Œ    |   | |
|   |   | æŒ‡é’ˆç±»å‹| -> | åç§»èŒƒå›´| -> | è®¿é—®å¤§å°| -> | è¯»/å†™   | -> | è®¿é—®    |   | |
|   |   |         |   |         |   |         |   | æƒé™    |   |         |   | |
|   |   +---------+   +---------+   +---------+   +---------+   +---------+   | |
|   |                                                                         | |
|   |   ç¤ºä¾‹: ldxw r0, [r1 + 8]                                               | |
|   |   +-----------------------------------------------------------------+   | |
|   |   | 1. r1 æ˜¯ PTR_TO_CTX? âœ“                                          |   | |
|   |   | 2. åç§» 8 åœ¨æœ‰æ•ˆèŒƒå›´å†…? âœ“ (å‡è®¾ ctx å¤§å° >= 12)                 |   | |
|   |   | 3. è®¿é—®å¤§å° 4 å­—èŠ‚å¯¹é½? âœ“                                       |   | |
|   |   | 4. è¯¥åç§»å¯è¯»? âœ“                                                |   | |
|   |   | 5. æ‰§è¡ŒåŠ è½½, r0 ç±»å‹æ ¹æ® ctx å­—æ®µç±»å‹ç¡®å®š                       |   | |
|   |   +-----------------------------------------------------------------+   | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                  CALL æŒ‡ä»¤ | CALL Instructions                          | |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   ä¸¤ç§è°ƒç”¨ç±»å‹:                                                         | |
|   |   Two call types:                                                       | |
|   |                                                                         | |
|   |   1. Helper è°ƒç”¨ (call imm):                                            | |
|   |   +-----------------------------------------------------------------+   | |
|   |   | â€¢ æ ¹æ® helper å‡½æ•°å®šä¹‰æ£€æŸ¥å‚æ•°ç±»å‹                              |   | |
|   |   | â€¢ æ ¹æ®è¿”å›å€¼ç±»å‹æ›´æ–° R0                                         |   | |
|   |   | â€¢ å¯èƒ½æ·»åŠ å¼•ç”¨ (å¦‚ map_lookup_elem)                             |   | |
|   |   | â€¢ R1-R5 å˜ä¸º NOT_INIT, R6-R9 ä¿æŒä¸å˜                          |   | |
|   |   +-----------------------------------------------------------------+   | |
|   |                                                                         | |
|   |   2. å­ç¨‹åºè°ƒç”¨ (call rel):                                             | |
|   |   +-----------------------------------------------------------------+   | |
|   |   | â€¢ ä¿å­˜å½“å‰å¸§åˆ° frame æ ˆ                                         |   | |
|   |   | â€¢ åˆ›å»ºæ–°å¸§ï¼Œå¤åˆ¶ R1-R5 ä½œä¸ºå‚æ•°                                 |   | |
|   |   | â€¢ è·³è½¬åˆ°å­ç¨‹åºå…¥å£                                              |   | |
|   |   | â€¢ è¿”å›æ—¶æ¢å¤è°ƒç”¨è€…çš„ R6-R9, æ›´æ–° R0                            |   | |
|   |   +-----------------------------------------------------------------+   | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 4.2 æ¡ä»¶åˆ†æ”¯ç»†åŒ–ä»£ç  | Conditional Branch Refinement Code

```rust
// æ–‡ä»¶ä½ç½®: crates/bpf-verifier-core/src/bounds/range_refine.rs

/// å¤„ç† JGT (æ— ç¬¦å·å¤§äº) åˆ†æ”¯
/// Handle JGT (unsigned greater than) branch
pub fn refine_jgt(
    state: &BpfVerifierState,
    dst_reg: usize,
    src_val: u64,  // æ¯”è¾ƒçš„å€¼
) -> (BpfVerifierState, BpfVerifierState) {
    let mut true_state = state.clone();
    let mut false_state = state.clone();
    
    // True åˆ†æ”¯: dst > src
    // dst_min è‡³å°‘æ˜¯ src + 1
    {
        let dst = &mut true_state.cur_func_mut().regs[dst_reg];
        dst.umin_value = dst.umin_value.max(src_val.saturating_add(1));
        
        // æ£€æŸ¥æ˜¯å¦ä¸å¯è¾¾
        if dst.umin_value > dst.umax_value {
            true_state.mark_unreachable();
        } else {
            // åŒæ­¥è¾¹ç•Œ
            reg_bounds_sync(dst);
        }
    }
    
    // False åˆ†æ”¯: dst <= src
    // dst_max æœ€å¤šæ˜¯ src
    {
        let dst = &mut false_state.cur_func_mut().regs[dst_reg];
        dst.umax_value = dst.umax_value.min(src_val);
        
        // æ£€æŸ¥æ˜¯å¦ä¸å¯è¾¾
        if dst.umin_value > dst.umax_value {
            false_state.mark_unreachable();
        } else {
            // åŒæ­¥è¾¹ç•Œ
            reg_bounds_sync(dst);
        }
    }
    
    (true_state, false_state)
}
```

---

## âœ‚ï¸ ç¬¬äº”é˜¶æ®µï¼šçŠ¶æ€å‰ªæ | Phase 5: State Pruning

### 5.1 ä¸ºä»€ä¹ˆéœ€è¦å‰ªæ | Why Pruning is Needed

```
+-----------------------------------------------------------------------------------+
|                          è·¯å¾„çˆ†ç‚¸é—®é¢˜                                          |
|                       Path Explosion Problem                                  |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   é—®é¢˜ç¤ºä¾‹ | Problem Example:                                                 |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |   if (c1) { ... }      // 2 æ¡è·¯å¾„                                      | |
|   |   if (c2) { ... }      // 2 æ¡è·¯å¾„                                      | |
|   |   if (c3) { ... }      // 2 æ¡è·¯å¾„                                      | |
|   |   ...                                                                   | |
|   |   if (c10) { ... }     // 2 æ¡è·¯å¾„                                      | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   æ€»è·¯å¾„æ•° = 2^10 = 1024 æ¡è·¯å¾„ï¼                                             |
|   Total paths = 2^10 = 1024 paths!                                            |
|                                                                                   |
|   æ›´å¤§çš„ç¨‹åºå¯èƒ½æœ‰ 2^100 æ¡è·¯å¾„...                                            |
|   Larger programs may have 2^100 paths...                                     |
|                                                                                   |
|   --------------------------------------------------------------------------- |
|                                                                                   |
|   è§£å†³æ–¹æ¡ˆï¼šçŠ¶æ€å‰ªæ | Solution: State Pruning                                |
|                                                                                   |
|   æ ¸å¿ƒæ€æƒ³ | Core Idea:                                                       |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   å¦‚æœåœ¨ç¨‹åºç‚¹ P å·²ç»éªŒè¯è¿‡çŠ¶æ€ S_oldï¼Œ                                 | |
|   |   ä¸”å½“å‰åˆ°è¾¾çš„çŠ¶æ€ S_new æ¯” S_old "æ›´ä¸¥æ ¼"ï¼Œ                            | |
|   |   é‚£ä¹ˆ S_new å¯ä»¥å®‰å…¨è·³è¿‡éªŒè¯ï¼                                         | |
|   |                                                                         | |
|   |   If at program point P we've verified state S_old,                     | |
|   |   and current state S_new is "more restrictive" than S_old,             | |
|   |   then S_new can safely skip verification!                              | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   ä¸ºä»€ä¹ˆå®‰å…¨ï¼Ÿ| Why is this safe?                                             |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   S_old = { r0 âˆˆ [0, 100] }      (æ›´å®½æ³›)                               | |
|   |   S_new = { r0 âˆˆ [10, 50] }      (æ›´ä¸¥æ ¼)                               | |
|   |                                                                         | |
|   |   å› ä¸º [10, 50] âŠ‚ [0, 100]ï¼Œ                                            | |
|   |   S_new èƒ½æ‰§è¡Œçš„æ“ä½œæ˜¯ S_old èƒ½æ‰§è¡Œçš„å­é›†ï¼Œ                             | |
|   |   æ‰€ä»¥ S_old å®‰å…¨æ„å‘³ç€ S_new ä¹Ÿå®‰å…¨ã€‚                                  | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 5.2 çŠ¶æ€åŒ…å«å…³ç³» | State Subsumption Relation

```
+-----------------------------------------------------------------------------------+
|                          çŠ¶æ€åŒ…å«å…³ç³»åˆ¤æ–­                                      |
|                    State Subsumption Determination                            |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   çŠ¶æ€ S_old åŒ…å« S_newï¼ˆS_old âŠ‡ S_newï¼‰çš„æ¡ä»¶:                               |
|   Conditions for S_old to subsume S_new (S_old âŠ‡ S_new):                      |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   1. ç±»å‹å…¼å®¹ | Type Compatibility                                      | |
|   |   -----------------------------------------------------------------    | |
|   |   æ¯ä¸ªå¯„å­˜å™¨çš„ç±»å‹å¿…é¡»å…¼å®¹:                                             | |
|   |                                                                         | |
|   |   old.reg_type     new.reg_type     ç»“æœ                                | |
|   |   --------------   --------------   ------                              | |
|   |   ScalarValue      ScalarValue      âœ“ å…¼å®¹                              | |
|   |   PtrToStack       PtrToStack       âœ“ å…¼å®¹                              | |
|   |   PtrToMapValue    ScalarValue      âœ— ä¸å…¼å®¹                            | |
|   |   NotInit          ScalarValue      âœ“ oldæ›´å®½æ³›                         | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   2. èŒƒå›´åŒ…å« | Range Containment                                       | |
|   |   -----------------------------------------------------------------    | |
|   |   old çš„èŒƒå›´å¿…é¡»åŒ…å« new çš„èŒƒå›´:                                        | |
|   |                                                                         | |
|   |   old: [0, 100]    new: [10, 50]    âœ“ å¯å‰ªæ                            | |
|   |   +-------------------------------------------------------------+       | |
|   |   |         [0                                        100]     |       | |
|   |   |              [10                    50]                    |       | |
|   |   |               ^                      ^                     |       | |
|   |   |               +----------------------+                     |       | |
|   |   |                    new âŠ‚ old                               |       | |
|   |   +-------------------------------------------------------------+       | |
|   |                                                                         | |
|   |   old: [10, 50]    new: [0, 100]    âœ— ä¸èƒ½å‰ªæ                          | |
|   |   +-------------------------------------------------------------+       | |
|   |   |         [0                                        100]     |       | |
|   |   |              [10                    50]                    |       | |
|   |   |         ^                                           ^      |       | |
|   |   |         +-------------------------------------------+      |       | |
|   |   |                    new âŠ„ old                               |       | |
|   |   +-------------------------------------------------------------+       | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   3. Tnum åŒ…å« | Tnum Containment                                       | |
|   |   -----------------------------------------------------------------    | |
|   |   old çš„ Tnum å¿…é¡»åŒ…å« new çš„ Tnum:                                     | |
|   |                                                                         | |
|   |   tnum_in(new, old) è¦æ±‚:                                               | |
|   |   â€¢ (new.value & old.mask) == 0                                         | |
|   |   â€¢ (new.mask & ~old.mask) == 0                                         | |
|   |                                                                         | |
|   |   ç¤ºä¾‹:                                                                 | |
|   |   old: { value: 0b1000, mask: 0b0111 }  è¡¨ç¤º 0b1xxx (8-15)             | |
|   |   new: { value: 0b1010, mask: 0b0001 }  è¡¨ç¤º 0b101x (10-11)            | |
|   |                                                                         | |
|   |   [10, 11] âŠ‚ [8, 15]  âœ“ å¯å‰ªæ                                         | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   4. ç²¾åº¦è¦æ±‚ | Precision Requirements                                  | |
|   |   -----------------------------------------------------------------    | |
|   |   å¦‚æœ old éœ€è¦ç²¾ç¡®è¿½è¸ªä½† new ä¸ç²¾ç¡®ï¼Œä¸èƒ½å‰ªæ                          | |
|   |                                                                         | |
|   |   old.precise = true, new.precise = false  âœ— ä¸èƒ½å‰ªæ                   | |
|   |   old.precise = false, new.precise = true  âœ“ å¯ä»¥å‰ªæ                   | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 5.3 å‰ªæå¯è§†åŒ– | Pruning Visualization

```
+-----------------------------------------------------------------------------------+
|                          çŠ¶æ€å‰ªæç¤ºä¾‹                                          |
|                     State Pruning Example                                     |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   ç¨‹åºç»“æ„ | Program Structure:                                               |
|                                                                                   |
|         +-----------+                                                         |
|         |  å…¥å£ç‚¹   |                                                         |
|         |  Entry    |                                                         |
|         +-----+-----+                                                         |
|               |                                                               |
|         +-----+-----+                                                         |
|         | if r1>50  |                                                         |
|         +-----+-----+                                                         |
|         +-----+-----+                                                         |
|         |           |                                                         |
|    +----v----+ +----v----+                                                    |
|    | Path A  | | Path B  |                                                    |
|    |r1âˆˆ[51,âˆ]| |r1âˆˆ[0,50]|                                                    |
|    +----+----+ +----+----+                                                    |
|         |           |                                                         |
|         +-----+-----+                                                         |
|               |                                                               |
|         +-----v-----+ <-- ç¨‹åºç‚¹ P (åˆå¹¶ç‚¹)                                   |
|         |   ...     |                                                         |
|         +-----------+                                                         |
|                                                                                   |
|   --------------------------------------------------------------------------- |
|                                                                                   |
|   å‰ªæè¿‡ç¨‹ | Pruning Process:                                                 |
|                                                                                   |
|   æ—¶åˆ» T1: Path A åˆ°è¾¾ç‚¹ Pï¼ŒçŠ¶æ€ S1 = { r1 âˆˆ [51, 100] }                      |
|   +-------------------------------------------------------------------------+ |
|   |  ç¼“å­˜çŠ¶æ€: cache[P] = S1                                                | |
|   |  ç»§ç»­éªŒè¯ P ä¹‹åçš„ä»£ç                                                   | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   æ—¶åˆ» T2: Path B åˆ°è¾¾ç‚¹ Pï¼ŒçŠ¶æ€ S2 = { r1 âˆˆ [0, 50] }                        |
|   +-------------------------------------------------------------------------+ |
|   |  æ£€æŸ¥: S1 âŠ‡ S2 ?                                                        | |
|   |        [51, 100] âŠ‡ [0, 50] ?                                            | |
|   |        å¦! [0, 50] ä¸åŒ…å«äº [51, 100]                                   | |
|   |                                                                         | |
|   |  æ— æ³•å‰ªæï¼Œç¼“å­˜çŠ¶æ€: cache[P] = { S1, S2 }                              | |
|   |  ç»§ç»­éªŒè¯ P ä¹‹åçš„ä»£ç                                                   | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   æ—¶åˆ» T3: å¦ä¸€æ¡è·¯å¾„åˆ°è¾¾ç‚¹ Pï¼ŒçŠ¶æ€ S3 = { r1 âˆˆ [60, 80] }                    |
|   +-------------------------------------------------------------------------+ |
|   |  æ£€æŸ¥: S1 âŠ‡ S3 ?                                                        | |
|   |        [51, 100] âŠ‡ [60, 80] ?                                           | |
|   |        æ˜¯! [60, 80] âŠ‚ [51, 100]                                         | |
|   |                                                                         | |
|   |  âœ“ å¯ä»¥å‰ªæï¼è·³è¿‡ S3 çš„åç»­éªŒè¯                                         | |
|   |                                                                         | |
|   |  åŸå› : S1 èƒ½åšçš„æ‰€æœ‰æ“ä½œ S3 éƒ½èƒ½åšï¼Œ                                    | |
|   |        S1 å®‰å…¨åˆ™ S3 å¿…å®šå®‰å…¨                                            | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 5.4 å‰ªæä»£ç  | Pruning Code

```rust
// æ–‡ä»¶ä½ç½®: crates/bpf-verifier-core/src/analysis/states_equal.rs

/// æ£€æŸ¥æ˜¯å¦å¯ä»¥å‰ªæ
/// Check if pruning is possible
pub fn states_maybe_looping(
    old: &BpfVerifierState,
    cur: &BpfVerifierState,
) -> bool {
    // æ£€æŸ¥æ‰€æœ‰å¯„å­˜å™¨
    for i in 0..MAX_BPF_REG {
        let old_reg = &old.cur_func().regs[i];
        let cur_reg = &cur.cur_func().regs[i];
        
        if !regsafe(old_reg, cur_reg) {
            return false;
        }
    }
    
    // æ£€æŸ¥æ ˆ
    if !stacksafe(old, cur) {
        return false;
    }
    
    // æ£€æŸ¥å¼•ç”¨
    if !refs_safe(old, cur) {
        return false;
    }
    
    true
}

/// æ£€æŸ¥å•ä¸ªå¯„å­˜å™¨æ˜¯å¦å®‰å…¨
/// Check if a single register is safe for pruning
fn regsafe(old: &BpfRegState, cur: &BpfRegState) -> bool {
    // ç±»å‹æ£€æŸ¥
    if old.reg_type == BpfRegType::NotInit {
        return true;  // old æ˜¯ NOT_INITï¼Œä»»ä½•çŠ¶æ€éƒ½å¯ä»¥
    }
    
    if old.reg_type != cur.reg_type {
        return false;  // ç±»å‹ä¸åŒï¼Œä¸èƒ½å‰ªæ
    }
    
    // å¯¹äºæ ‡é‡ï¼Œæ£€æŸ¥èŒƒå›´
    if old.reg_type == BpfRegType::ScalarValue {
        // old çš„èŒƒå›´å¿…é¡»åŒ…å« cur çš„èŒƒå›´
        if old.smin_value > cur.smin_value || 
           old.smax_value < cur.smax_value {
            return false;
        }
        if old.umin_value > cur.umin_value || 
           old.umax_value < cur.umax_value {
            return false;
        }
        
        // Tnum æ£€æŸ¥
        if !tnum_in(cur.var_off, old.var_off) {
            return false;
        }
    }
    
    // ç²¾åº¦æ£€æŸ¥
    if old.precise && !cur.precise {
        return false;
    }
    
    true
}
```

---

## âœ… ç¬¬å…­é˜¶æ®µï¼šéªŒè¯å®Œæˆ | Phase 6: Verification Complete

### 6.1 æˆåŠŸæ¡ä»¶ | Success Conditions

```
+-----------------------------------------------------------------------------------+
|                          éªŒè¯æˆåŠŸæ¡ä»¶                                          |
|                   Verification Success Conditions                             |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   éªŒè¯å™¨å®£å¸ƒç¨‹åºå®‰å…¨éœ€è¦æ»¡è¶³æ‰€æœ‰æ¡ä»¶:                                         |
|   All conditions must be met for the verifier to declare the program safe:    |
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |   âœ“ æ‰€æœ‰å¯è¾¾è·¯å¾„éƒ½å·²éªŒè¯                                                | |
|   |     All reachable paths have been verified                              | |
|   |                                                                         | |
|   |   âœ“ æ²¡æœ‰è¶Šç•Œå†…å­˜è®¿é—®                                                    | |
|   |     No out-of-bounds memory access                                      | |
|   |                                                                         | |
|   |   âœ“ æ²¡æœ‰è¯»å–æœªåˆå§‹åŒ–çš„æ•°æ®                                              | |
|   |     No reads of uninitialized data                                      | |
|   |                                                                         | |
|   |   âœ“ æ²¡æœ‰ç±»å‹è¿è§„                                                        | |
|   |     No type violations                                                  | |
|   |                                                                         | |
|   |   âœ“ æ‰€æœ‰å¼•ç”¨åœ¨é€€å‡ºå‰é‡Šæ”¾                                                | |
|   |     All references released before exit                                 | |
|   |                                                                         | |
|   |   âœ“ æ‰€æœ‰é”åœ¨é€€å‡ºå‰é‡Šæ”¾                                                  | |
|   |     All locks released before exit                                      | |
|   |                                                                         | |
|   |   âœ“ ç¨‹åºä¸€å®šä¼šç»ˆæ­¢ï¼ˆæ— æ— ç•Œå¾ªç¯ï¼‰                                        | |
|   |     Program definitely terminates (no unbounded loops)                  | |
|   |                                                                         | |
|   |   âœ“ æŒ‡ä»¤æ•°æœªè¶…è¿‡é™åˆ¶                                                    | |
|   |     Instruction count within limit                                      | |
|   |                                                                         | |
|   |   âœ“ è¿”å›å€¼ R0 å·²æ­£ç¡®è®¾ç½®                                                | |
|   |     Return value R0 properly set                                        | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 6.2 å¸¸è§é”™è¯¯ç±»å‹ | Common Error Types

```
+-----------------------------------------------------------------------------------+
|                          å¸¸è§éªŒè¯é”™è¯¯                                          |
|                    Common Verification Errors                                 |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-------------------------------------------------------------------------+ |
|   | é”™è¯¯ç±»å‹            | æè¿°                      | ç¤ºä¾‹                  | |
|   +---------------------+---------------------------+-----------------------+ |
|   | OUT_OF_BOUNDS       | è®¿é—®è¶…å‡ºæœ‰æ•ˆèŒƒå›´          | *(r1 + 1000)         | |
|   |                     | Access out of bounds      |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | UNINIT_READ         | è¯»å–æœªåˆå§‹åŒ–å¯„å­˜å™¨        | r0 = r3 (r3æœªè®¾ç½®)   | |
|   |                     | Read uninitialized reg    |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | TYPE_MISMATCH       | ç±»å‹ä¸æ­£ç¡®                | ç”¨æ ‡é‡åšæŒ‡é’ˆ          | |
|   |                     | Incorrect type            |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | LEAKED_REFERENCE    | é€€å‡ºæ—¶æœªé‡Šæ”¾å¼•ç”¨          | map_lookupåæ²¡æ£€æŸ¥    | |
|   |                     | Reference not released    |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | UNRELEASED_LOCK     | é€€å‡ºæ—¶æœªé‡Šæ”¾é”            | spin_lockåæ²¡unlock  | |
|   |                     | Lock not released         |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | UNBOUNDED_LOOP      | å¯èƒ½çš„æ— é™å¾ªç¯            | while(1) { }         | |
|   |                     | Possible infinite loop    |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | TOO_MANY_INSNS      | éªŒè¯æŒ‡ä»¤æ•°è¶…é™            | ç¨‹åºå¤ªå¤æ‚            | |
|   |                     | Too many instructions     |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|   | INVALID_HELPER      | è°ƒç”¨æ— æ•ˆçš„ helper         | ç¨‹åºç±»å‹ä¸æ”¯æŒ        | |
|   |                     | Invalid helper call       |                       | |
|   +---------------------+---------------------------+-----------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## ğŸ“š å®Œæ•´éªŒè¯ç¤ºä¾‹ | Complete Verification Example

```
+-----------------------------------------------------------------------------------+
|                          å®Œæ•´éªŒè¯æµç¨‹è¿½è¸ª                                      |
|                   Complete Verification Flow Trace                            |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   ç¤ºä¾‹ç¨‹åº | Example Program:                                                 |
|   +-------------------------------------------------------------------------+ |
|   |  0: r0 = 0                  // åˆå§‹åŒ–è¿”å›å€¼                             | |
|   |  1: r2 = *(u32*)(r1 + 0)    // ä»ä¸Šä¸‹æ–‡è¯»å–                             | |
|   |  2: if r2 > 100 goto 4      // è¾¹ç•Œæ£€æŸ¥                                 | |
|   |  3: r0 = 1                  // è®¾ç½®æˆåŠŸè¿”å›                             | |
|   |  4: exit                    // ç¨‹åºé€€å‡º                                 | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   --------------------------------------------------------------------------- |
|                                                                                   |
|   Step 0: åˆå§‹åŒ– | Initialization                                             |
|   +-------------------------------------------------------------------------+ |
|   |  å¯„å­˜å™¨çŠ¶æ€:                                                            | |
|   |  R0  = NOT_INIT                                                         | |
|   |  R1  = PTR_TO_CTX                                                       | |
|   |  R2-R9 = NOT_INIT                                                       | |
|   |  R10 = PTR_TO_STACK                                                     | |
|   |                                                                         | |
|   |  å·¥ä½œåˆ—è¡¨: [(State0, insn=0)]                                           | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 1: æ‰§è¡Œ insn 0 (r0 = 0)                                                |
|   +-------------------------------------------------------------------------+ |
|   |  æ“ä½œ: å°†å¸¸æ•° 0 ç§»åŠ¨åˆ° R0                                               | |
|   |                                                                         | |
|   |  æ›´æ–°: R0 = SCALAR { umin=0, umax=0, smin=0, smax=0 }                   | |
|   |                                                                         | |
|   |  ç»“æœ: Continue -> ç»§ç»­ insn 1                                           | |
|   |  å·¥ä½œåˆ—è¡¨: [(State1, insn=1)]                                           | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 2: æ‰§è¡Œ insn 1 (r2 = *(u32*)(r1 + 0))                                  |
|   +-------------------------------------------------------------------------+ |
|   |  æ£€æŸ¥:                                                                  | |
|   |  1. R1 æ˜¯å¦æ˜¯æœ‰æ•ˆæŒ‡é’ˆ? âœ“ (PTR_TO_CTX)                                   | |
|   |  2. åç§» 0 + å¤§å° 4 æ˜¯å¦åœ¨ ctx èŒƒå›´å†…? âœ“                                | |
|   |  3. è¯¥å­—æ®µæ˜¯å¦å¯è¯»? âœ“                                                   | |
|   |                                                                         | |
|   |  æ›´æ–°: R2 = SCALAR { umin=0, umax=0xFFFFFFFF }                          | |
|   |        (ä» ctx è¯»å–çš„ 32 ä½å€¼ï¼ŒèŒƒå›´å®Œå…¨æœªçŸ¥)                            | |
|   |                                                                         | |
|   |  ç»“æœ: Continue -> ç»§ç»­ insn 2                                           | |
|   |  å·¥ä½œåˆ—è¡¨: [(State2, insn=2)]                                           | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 3: æ‰§è¡Œ insn 2 (if r2 > 100 goto 4)                                    |
|   +-------------------------------------------------------------------------+ |
|   |  æ¡ä»¶åˆ†æ”¯: r2 > 100                                                     | |
|   |                                                                         | |
|   |  äº§ç”Ÿä¸¤ä¸ªçŠ¶æ€:                                                          | |
|   |                                                                         | |
|   |  True åˆ†æ”¯ (è·³è½¬åˆ° insn 4):                                             | |
|   |    R2 = SCALAR { umin=101, umax=0xFFFFFFFF }                            | |
|   |                                                                         | |
|   |  False åˆ†æ”¯ (ç»§ç»­ insn 3):                                              | |
|   |    R2 = SCALAR { umin=0, umax=100 }                                     | |
|   |                                                                         | |
|   |  å·¥ä½œåˆ—è¡¨: [(State3a, insn=4), (State3b, insn=3)]                       | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 4a: å¤„ç† False åˆ†æ”¯ (State3b @ insn 3)                                 |
|   +-------------------------------------------------------------------------+ |
|   |  æ‰§è¡Œ insn 3 (r0 = 1):                                                  | |
|   |                                                                         | |
|   |  æ›´æ–°: R0 = SCALAR { umin=1, umax=1 }                                   | |
|   |                                                                         | |
|   |  ç»“æœ: Continue -> ç»§ç»­ insn 4                                           | |
|   |  å·¥ä½œåˆ—è¡¨: [(State3a, insn=4), (State4, insn=4)]                        | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 4b: å¤„ç† State4 @ insn 4 (exit)                                        |
|   +-------------------------------------------------------------------------+ |
|   |  æ‰§è¡Œ insn 4 (exit):                                                    | |
|   |                                                                         | |
|   |  é€€å‡ºæ£€æŸ¥:                                                              | |
|   |  1. R0 å·²åˆå§‹åŒ–? âœ“ (SCALAR)                                             | |
|   |  2. æ‰€æœ‰å¼•ç”¨å·²é‡Šæ”¾? âœ“ (æ— å¼•ç”¨)                                          | |
|   |  3. æ‰€æœ‰é”å·²é‡Šæ”¾? âœ“ (æ— é”)                                              | |
|   |                                                                         | |
|   |  ç»“æœ: Exit -> æ­¤è·¯å¾„éªŒè¯å®Œæˆ                                            | |
|   |  å·¥ä½œåˆ—è¡¨: [(State3a, insn=4)]                                          | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 5: å¤„ç† State3a @ insn 4 (exit)                                        |
|   +-------------------------------------------------------------------------+ |
|   |  æ‰§è¡Œ insn 4 (exit):                                                    | |
|   |                                                                         | |
|   |  é€€å‡ºæ£€æŸ¥:                                                              | |
|   |  1. R0 å·²åˆå§‹åŒ–? âœ“ (SCALAR, å€¼ä¸º 0)                                     | |
|   |  2. æ‰€æœ‰å¼•ç”¨å·²é‡Šæ”¾? âœ“                                                   | |
|   |  3. æ‰€æœ‰é”å·²é‡Šæ”¾? âœ“                                                     | |
|   |                                                                         | |
|   |  ç»“æœ: Exit -> æ­¤è·¯å¾„éªŒè¯å®Œæˆ                                            | |
|   |  å·¥ä½œåˆ—è¡¨: []                                                           | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
|   Step 6: éªŒè¯å®Œæˆ!                                                           |
|   +-------------------------------------------------------------------------+ |
|   |                                                                         | |
|   |  å·¥ä½œåˆ—è¡¨ä¸ºç©ºï¼Œæ‰€æœ‰è·¯å¾„éƒ½å·²éªŒè¯                                         | |
|   |  æ²¡æœ‰å‘ç°ä»»ä½•å®‰å…¨é—®é¢˜                                                   | |
|   |                                                                         | |
|   |  +-------------------------------------------------------------------+  | |
|   |  |              éªŒè¯ç»“æœ: æˆåŠŸ âœ“                                      |  | |
|   |  |              Verification Result: SUCCESS âœ“                       |  | |
|   |  +-------------------------------------------------------------------+  | |
|   |                                                                         | |
|   +-------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## ğŸ“ å°ç»“ | Summary

æœ¬ç« ä»‹ç»äº†éªŒè¯å™¨çš„å®Œæ•´å·¥ä½œæµç¨‹ï¼š

| é˜¶æ®µ | å…³é”®æ“ä½œ | ä»£ç ä½ç½® |
|------|---------|---------|
| åæ±‡ç¼– | è§£æå­—èŠ‚ç ä¸ºæŒ‡ä»¤ | `core/disasm.rs` |
| CFGæ„å»º | è¯†åˆ«åŸºæœ¬å—å’Œè¾¹ | `analysis/cfg.rs` |
| çŠ¶æ€åˆå§‹åŒ– | è®¾ç½®åˆå§‹å¯„å­˜å™¨å’Œæ ˆ | `state/verifier_state.rs` |
| ä¸»å¾ªç¯ | å·¥ä½œåˆ—è¡¨ç®—æ³• | `verifier/main_loop.rs` |
| æŒ‡ä»¤æ¨¡æ‹Ÿ | æŠ½è±¡æ‰§è¡Œæ¯æ¡æŒ‡ä»¤ | `core/insn_verify.rs` |
| çŠ¶æ€å‰ªæ | é¿å…é‡å¤éªŒè¯ | `analysis/states_equal.rs` |

---

## ğŸ“ ç»ƒä¹  | Exercises

1. æ‰‹åŠ¨è¿½è¸ªä¸€ä¸ªåŒ…å«å¾ªç¯çš„ BPF ç¨‹åºçš„éªŒè¯è¿‡ç¨‹
2. ç»™å‡ºä¸¤ä¸ªçŠ¶æ€ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥å‰ªæå¹¶è§£é‡ŠåŸå› 
3. åˆ†æä»€ä¹ˆæƒ…å†µä¸‹çŠ¶æ€å‰ªææ— æ³•ç”Ÿæ•ˆ

---

## ğŸ”— ä»£ç ä½ç½®ç´¢å¼• | Code Location Index

| åŠŸèƒ½ | æ–‡ä»¶è·¯å¾„ |
|------|---------|
| åæ±‡ç¼– | `core/disasm.rs` |
| CFG æ„å»º | `analysis/cfg.rs` |
| ä¸»éªŒè¯å¾ªç¯ | `verifier/main_loop.rs` |
| æŒ‡ä»¤æ¨¡æ‹Ÿ | `core/insn_verify.rs` |
| çŠ¶æ€æ¯”è¾ƒ | `analysis/states_equal.rs` |
| çŠ¶æ€åˆå¹¶ | `analysis/state_merge.rs` |

---

ğŸ‘‰ [ä¸‹ä¸€ç« ï¼šè¾¹ç•Œåˆ†æ | Next: Bounds Analysis](07-bounds-analysis.md)
