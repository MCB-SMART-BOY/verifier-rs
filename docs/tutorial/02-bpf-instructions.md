# 第二章：BPF 指令集入门

# Chapter 2: BPF Instruction Set Primer

```
+-----------------------------------------------------------------------------------+
|                                                                                   |
|     ██████+ ██████+ ███████+    ██+███+   ██+███████+████████+██████+             |
|     ██+--██+██+--██+██+----+    ██|████+  ██|██+----++--██+--+██+--██+            |
|     ██████++██████++█████+      ██|██+██+ ██|███████+   ██|   ██████++            |
|     ██+--██+██+---+ ██+--+      ██|██|+██+██|+----██|   ██|   ██+--██+            |
|     ██████++██|     ██|         ██|██| +████|███████|   ██|   ██|  ██|            |
|     +-----+ +-+     +-+         +-++-+  +---++------+   +-+   +-+  +-+            |
|                                                                                   |
|                         BPF Instruction Set Architecture                          |
|                           BPF 指令 = 你要学的"新语言"                             |
|                           别担心，它比 x86 简单多了！                             |
+-----------------------------------------------------------------------------------+
```

## 本章目标 | Chapter Goals

学完这章，你将能够：
- 理解 BPF 指令的二进制格式
- 认识所有主要的指令类别
- 读懂并编写简单的 BPF 程序
- 知道指令与我们项目代码的对应关系

---

## 指令格式详解 | Instruction Format Details

### 基本格式 | Basic Format

每条 BPF 指令是 **64 位**（8 字节）固定长度：

```
+-----------------------------------------------------------------------------------+
|                          BPF 指令编码格式 (64 bits)                               |
|                       BPF Instruction Encoding Format                             |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   位 (bit)       63      48 47      32 31      16 15  12 11   8 7            0    |
|                  v         v         v         v   v     v      v            v    |
|                 +----------+----------+----------+------+------+----------+       |
|   字段:         |immediate |immediate |  offset  | src  | dst  |  opcode  |       |
|                 |(高16位)  |(低16位)  | (有符号) |      |      |          |       |
|                 +----------+----------+----------+------+------+----------+       |
|   大小:         |      32 bits        | 16 bits  |4 bits|4 bits|  8 bits  |       |
|                 +---------------------+----------+------+------+----------+       |
|                                                                                   |
|   内存布局 (小端序 / Little Endian):                                              |
|                                                                                   |
|    字节 0       字节 1      字节 2-3        字节 4-7                              |
|   +--------+  +--------+  +----------+  +--------------------+                    |
|   | opcode |  |dst|src |  |  offset  |  |    immediate       |                    |
|   | 操作码 |  | 4 | 4  |  |   偏移   |  |      立即数        |                    |
|   |        |  |bit|bit |  |  16 bit  |  |     32 bit         |                    |
|   +--------+  +--------+  +----------+  +--------------------+                    |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 在 Rust 代码中的表示 | Rust Representation

```rust
// 文件: crates/bpf-verifier-core/src/core/insn.rs

/// BPF 指令结构
/// BPF Instruction Structure
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct BpfInsn {
    /// 操作码 - 定义指令类型和操作
    /// Opcode - defines instruction type and operation
    pub code: u8,
    
    /// 目标寄存器 (0-10)
    /// Destination register (0-10)
    pub dst_reg: u8,
    
    /// 源寄存器 (0-10)
    /// Source register (0-10)  
    pub src_reg: u8,
    
    /// 偏移量 - 用于内存访问和跳转
    /// Offset - used for memory access and jumps
    pub off: i16,
    
    /// 立即数 - 常量值
    /// Immediate - constant value
    pub imm: i32,
}
```

### 操作码 (Opcode) 编码 | Opcode Encoding

```
+-----------------------------------------------------------------------------------+
|                           操作码 (Opcode) 结构                                    |
|                           Opcode Structure                                        |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   8 位操作码分为三个部分:                                                         |
|   8-bit opcode is divided into three parts:                                       |
|                                                                                   |
|        位 7   位 6   位 5   位 4   位 3   位 2   位 1   位 0                      |
|       +----------------------+------------------------------+                     |
|       |   操作 (operation)   |   指令类别 (instruction class) |                    |
|       |       4 bits         |           3 bits              |                    |
|       +----------------------+------------------------------+                     |
|                 |                           |                                     |
|                 |                           |                                     |
|                 v                           v                                     |
|   +-------------------------+   +-----------------------------------------+       |
|   | ALU 操作:               |   | 指令类别:                               |       |
|   |                         |   |                                         |       |
|   | 0x0 = ADD  0x1 = SUB    |   | 0x0 (0b000) = LD    加载 (遗留)         |       |
|   | 0x2 = MUL  0x3 = DIV    |   | 0x1 (0b001) = LDX   加载到寄存器        |       |
|   | 0x4 = OR   0x5 = AND    |   | 0x2 (0b010) = ST    存储立即数          |       |
|   | 0x6 = LSH  0x7 = RSH    |   | 0x3 (0b011) = STX   存储寄存器          |       |
|   | 0x8 = NEG  0x9 = MOD    |   | 0x4 (0b100) = ALU   32位算术            |       |
|   | 0xa = XOR  0xb = MOV    |   | 0x5 (0b101) = JMP   64位跳转            |       |
|   | 0xc = ARSH              |   | 0x6 (0b110) = JMP32 32位跳转            |       |
|   | 0xd = END               |   | 0x7 (0b111) = ALU64 64位算术            |       |
|   |                         |   |                                         |       |
|   | JMP 操作:               |   +-----------------------------------------+       |
|   |                         |                                                     |
|   | 0x0 = JA   0x1 = JEQ    |   +-----------------------------------------+       |
|   | 0x2 = JGT  0x3 = JGE    |   | 源操作数标志 (bit 3):                   |       |
|   | 0x4 = JSET 0x5 = JNE    |   |                                         |       |
|   | 0x6 = JSGT 0x7 = JSGE   |   | 0x00 = BPF_K  使用立即数                |       |
|   | 0x8 = CALL 0x9 = EXIT   |   | 0x08 = BPF_X  使用源寄存器              |       |
|   | 0xa = JLT  0xb = JLE    |   |                                         |       |
|   | 0xc = JSLT 0xd = JSLE   |   +-----------------------------------------+       |
|   +-------------------------+                                                     |
|                                                                                   |
|   示例解码:                                                                       |
|   -------------------------------------------------------------------------       |
|                                                                                   |
|   0x07 = 0b0000_0111                                                              |
|          ------------                                                             |
|          |      |                                                                 |
|          |      +-- class = 0b111 = ALU64                                         |
|          +-- op = 0b0000 = ADD                                                    |
|                                                                                   |
|   结果: 64位加法指令，使用立即数 (BPF_K)                                          |
|                                                                                   |
|   0xbf = 0b1011_1111                                                              |
|          ------------                                                             |
|          |      |                                                                 |
|          |      +-- class = 0b111 = ALU64                                         |
|          +-- op = 0b1011 = MOV                                                    |
|              src = 0x08 = BPF_X (使用寄存器)                                      |
|                                                                                   |
|   结果: 64位寄存器间移动指令                                                      |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 指令类别总览 | Instruction Categories Overview

```
+-----------------------------------------------------------------------------------+
|                            BPF 指令类别                                           |
|                       BPF Instruction Categories                                  |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|  ╭---------------------------------------------------------------------------╮    |
|  |                      1. ALU 指令 (算术逻辑运算)                           |    |
|  |                         Arithmetic Logic Unit                             |    |
|  +---------------------------------------------------------------------------+    |
|  |                                                                           |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |   |  算术运算                        逻辑运算                         |   |    |
|  |   |  Arithmetic                      Logical                          |   |    |
|  |   |                                                                   |   |    |
|  |   |  ADD  加法                       AND  按位与                      |   |    |
|  |   |  SUB  减法                       OR   按位或                      |   |    |
|  |   |  MUL  乘法                       XOR  按位异或                    |   |    |
|  |   |  DIV  除法                       LSH  逻辑左移                    |   |    |
|  |   |  MOD  取模                       RSH  逻辑右移                    |   |    |
|  |   |  NEG  取负                       ARSH 算术右移                    |   |    |
|  |   |  MOV  移动                                                        |   |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |                                                                           |    |
|  |   格式: dst = dst OP src  或  dst = dst OP imm                           |    |
|  |   Modes: ALU (32-bit) 或 ALU64 (64-bit)                                  |    |
|  |                                                                           |    |
|  ╰---------------------------------------------------------------------------╯    |
|                                                                                   |
|  ╭---------------------------------------------------------------------------╮    |
|  |                      2. MEM 指令 (内存访问)                               |    |
|  |                         Memory Operations                                 |    |
|  +---------------------------------------------------------------------------+    |
|  |                                                                           |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |   |  加载 (Load)                     存储 (Store)                     |   |    |
|  |   |                                                                   |   |    |
|  |   |  LDXB  加载 1 字节               STXB  存储 1 字节                |   |    |
|  |   |  LDXH  加载 2 字节               STXH  存储 2 字节                |   |    |
|  |   |  LDXW  加载 4 字节               STXW  存储 4 字节                |   |    |
|  |   |  LDXDW 加载 8 字节               STXDW 存储 8 字节                |   |    |
|  |   |                                                                   |   |    |
|  |   |  大小编码 (Size Encoding):                                        |   |    |
|  |   |  +---------+-------+------+                                       |   |    |
|  |   |  |  代码   | 大小  | 后缀 |                                       |   |    |
|  |   |  +---------+-------+------+                                       |   |    |
|  |   |  |  0x00   | 4字节 |  W   |  (Word)                               |   |    |
|  |   |  |  0x08   | 2字节 |  H   |  (Half-word)                          |   |    |
|  |   |  |  0x10   | 1字节 |  B   |  (Byte)                               |   |    |
|  |   |  |  0x18   | 8字节 |  DW  |  (Double-word)                        |   |    |
|  |   |  +---------+-------+------+                                       |   |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |                                                                           |    |
|  |   格式: dst = *(type *)(src + off)  或  *(type *)(dst + off) = src       |    |
|  |                                                                           |    |
|  ╰---------------------------------------------------------------------------╯    |
|                                                                                   |
|  ╭---------------------------------------------------------------------------╮    |
|  |                      3. JMP 指令 (跳转控制)                               |    |
|  |                         Jump Operations                                   |    |
|  +---------------------------------------------------------------------------+    |
|  |                                                                           |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |   |  无条件跳转                      条件跳转 (无符号)                |   |    |
|  |   |  Unconditional                   Conditional (Unsigned)           |   |    |
|  |   |                                                                   |   |    |
|  |   |  JA   总是跳转                   JEQ  相等跳转                    |   |    |
|  |   |  CALL 调用辅助函数               JNE  不等跳转                    |   |    |
|  |   |  EXIT 程序退出                   JGT  大于跳转                    |   |    |
|  |   |                                  JGE  大于等于跳转                |   |    |
|  |   |                                  JLT  小于跳转                    |   |    |
|  |   |  条件跳转 (有符号)               JLE  小于等于跳转                |   |    |
|  |   |  Conditional (Signed)            JSET 位测试跳转                  |   |    |
|  |   |                                                                   |   |    |
|  |   |  JSGT 有符号大于                                                  |   |    |
|  |   |  JSGE 有符号大于等于                                              |   |    |
|  |   |  JSLT 有符号小于                                                  |   |    |
|  |   |  JSLE 有符号小于等于                                              |   |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |                                                                           |    |
|  |   格式: if (dst OP src) goto +off                                        |    |
|  |   跳转目标: PC + 1 + off (相对于下一条指令)                              |    |
|  |                                                                           |    |
|  ╰---------------------------------------------------------------------------╯    |
|                                                                                   |
|  ╭---------------------------------------------------------------------------╮    |
|  |                      4. ATOMIC 指令 (原子操作)                            |    |
|  |                         Atomic Operations                                 |    |
|  +---------------------------------------------------------------------------+    |
|  |                                                                           |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |   |  XADD     原子加法               lock *(dst + off) += src        |   |    |
|  |   |  XCHG     原子交换               src, *(dst+off) = *(dst+off),src|   |    |
|  |   |  CMPXCHG  原子比较交换           if (*dst == R0) *dst = src      |   |    |
|  |   |  XAND     原子与                 lock *(dst + off) &= src        |   |    |
|  |   |  XOR      原子或                 lock *(dst + off) |= src        |   |    |
|  |   |  XXOR     原子异或               lock *(dst + off) ^= src        |   |    |
|  |   +-------------------------------------------------------------------+   |    |
|  |                                                                           |    |
|  |   用途: 多 CPU 环境下的安全并发访问                                       |    |
|  |                                                                           |    |
|  ╰---------------------------------------------------------------------------╯    |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## ALU 指令详解 | ALU Instructions in Detail

### 算术运算指令 | Arithmetic Instructions

```
+-----------------------------------------------------------------------------------+
|                            ALU 算术运算指令                                       |
|                       ALU Arithmetic Instructions                                 |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |    指令          |   操作           |   语义                |   示例        | |
|   +-----------------------------------------------------------------------------+ |
|   |                                                                             | |
|   |   add dst, src   |   dst += src     |   加法               | r1 += r2      | |
|   |   add dst, imm   |   dst += imm     |   加立即数           | r1 += 10      | |
|   |                                                                             | |
|   |   sub dst, src   |   dst -= src     |   减法               | r1 -= r2      | |
|   |   sub dst, imm   |   dst -= imm     |   减立即数           | r1 -= 10      | |
|   |                                                                             | |
|   |   mul dst, src   |   dst *= src     |   乘法               | r1 *= r2      | |
|   |   mul dst, imm   |   dst *= imm     |   乘立即数           | r1 *= 10      | |
|   |                                                                             | |
|   |   div dst, src   |   dst /= src     |   无符号除法         | r1 /= r2      | |
|   |   div dst, imm   |   dst /= imm     |   除立即数           | r1 /= 10      | |
|   |   sdiv dst, src  |   dst /= src     |   有符号除法         | r1 /= r2      | |
|   |                                                                             | |
|   |   mod dst, src   |   dst %= src     |   无符号取模         | r1 %= r2      | |
|   |   mod dst, imm   |   dst %= imm     |   模立即数           | r1 %= 10      | |
|   |   smod dst, src  |   dst %= src     |   有符号取模         | r1 %= r2      | |
|   |                                                                             | |
|   |   neg dst        |   dst = -dst     |   取负               | r1 = -r1      | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   示例程序: 计算 (5 + 3) * 2                                                      |
|   Example: Calculate (5 + 3) * 2                                                  |
|                                                                                   |
|   +----+------------------+----------------------------------------------------+  |
|   | #  | 指令              | 效果                                               |  |
|   +----+------------------+----------------------------------------------------+  |
|   | 0  | mov r1, 5        | R1 = 5                                             |  |
|   | 1  | add r1, 3        | R1 = R1 + 3 = 8                                    |  |
|   | 2  | mul r1, 2        | R1 = R1 * 2 = 16                                   |  |
|   | 3  | mov r0, r1       | R0 = R1 = 16 (设置返回值)                          |  |
|   | 4  | exit             | 返回 R0 = 16                                       |  |
|   +----+------------------+----------------------------------------------------+  |
|                                                                                   |
|   执行过程可视化:                                                                 |
|                                                                                   |
|    指令 #0                指令 #1                指令 #2                          |
|   +--------+            +--------+            +--------+                          |
|   | R1 = 5 |     -->    | R1 = 8 |     -->    | R1 = 16|                          |
|   +--------+            +--------+            +--------+                          |
|       |                     |                     |                               |
|       |   mov r1, 5         |   add r1, 3         |   mul r1, 2                   |
|       v                     v                     v                               |
|   +--------+            +--------+            +--------+                          |
|   | R0 = ? |            | R0 = ? |            | R0 = ? |                          |
|   +--------+            +--------+            +--------+                          |
|                                                                                   |
|                                                    指令 #3                        |
|                                                   +--------+                      |
|                                         -->       | R0 = 16|  -->  exit           |
|                                                   +--------+       返回 16        |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 逻辑运算和位移指令 | Logical and Shift Instructions

```
+-----------------------------------------------------------------------------------+
|                           ALU 逻辑运算和位移指令                                  |
|                       ALU Logical and Shift Instructions                          |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |    指令          |   操作           |   语义                                | |
|   +-----------------------------------------------------------------------------+ |
|   |                                                                             | |
|   |   and dst, src   |   dst &= src     |   按位与                              | |
|   |   or  dst, src   |   dst |= src     |   按位或                              | |
|   |   xor dst, src   |   dst ^= src     |   按位异或                            | |
|   |                                                                             | |
|   |   lsh dst, src   |   dst <<= src    |   逻辑左移 (低位补0)                  | |
|   |   rsh dst, src   |   dst >>= src    |   逻辑右移 (高位补0)                  | |
|   |   arsh dst, src  |   dst >>>= src   |   算术右移 (保留符号位)               | |
|   |                                                                             | |
|   |   mov dst, src   |   dst = src      |   寄存器间复制                        | |
|   |   mov dst, imm   |   dst = imm      |   加载立即数                          | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   位移操作可视化:                                                                 |
|   Shift Operation Visualization:                                                  |
|                                                                                   |
|   原始值 (R1 = 0x0F):                                                             |
|   +---+---+---+---+---+---+---+---+                                               |
|   | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |  = 0x0F = 15                                  |
|   +---+---+---+---+---+---+---+---+                                               |
|                                                                                   |
|   lsh r1, 2  (逻辑左移 2 位):                                                     |
|   +---+---+---+---+---+---+---+---+                                               |
|   | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |  = 0x3C = 60                                  |
|   +---+---+---+---+---+---+---+---+                                               |
|       <------------------- 左移, 低位补 0                                         |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   原始值 (R1 = 0xF0):                                                             |
|   +---+---+---+---+---+---+---+---+                                               |
|   | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = 0xF0 = 240 (无符号) / -16 (有符号)         |
|   +---+---+---+---+---+---+---+---+                                               |
|                                                                                   |
|   rsh r1, 2  (逻辑右移 2 位):                                                     |
|   +---+---+---+---+---+---+---+---+                                               |
|   | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |  = 0x3C = 60                                  |
|   +---+---+---+---+---+---+---+---+                                               |
|       高位补 0 ------------------->                                               |
|                                                                                   |
|   arsh r1, 2  (算术右移 2 位):                                                    |
|   +---+---+---+---+---+---+---+---+                                               |
|   | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |  = 0xFC = -4 (有符号)                         |
|   +---+---+---+---+---+---+---+---+                                               |
|       保留符号位 ----------------->                                               |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

### 32位 vs 64位操作 | 32-bit vs 64-bit Operations

```
+-----------------------------------------------------------------------------------+
|                          32位 vs 64位 ALU 操作                                    |
|                       32-bit vs 64-bit ALU Operations                             |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   BPF 寄存器都是 64 位，但指令可以选择操作 32 位或 64 位:                         |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                           64 位寄存器结构                                   | |
|   |                                                                             | |
|   |    位 63                              位 31                      位 0       | |
|   |   +--------------------------------+--------------------------------+       | |
|   |   |           高 32 位              |            低 32 位           |       | |
|   |   |         (bits 63-32)            |          (bits 31-0)          |       | |
|   |   +--------------------------------+--------------------------------+       | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   64 位操作 (ALU64, opcode class = 0x07):                                         |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                                                                             | |
|   |   add64 r1, 1    // 整个 64 位都参与运算                                    | |
|   |                                                                             | |
|   |   之前: +------------------------+------------------------+                | |
|   |         |  0x00000000            |    0xFFFFFFFF          |                | |
|   |         +------------------------+------------------------+                | |
|   |                                                                             | |
|   |   之后: +------------------------+------------------------+                | |
|   |         |  0x00000001            |    0x00000000          |                | |
|   |         +------------------------+------------------------+                | |
|   |                  ^                                                          | |
|   |                  +--- 进位传播到高 32 位                                    | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   32 位操作 (ALU, opcode class = 0x04):                                           |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                                                                             | |
|   |   add32 r1, 1    // 只操作低 32 位，高 32 位被清零!                         | |
|   |                                                                             | |
|   |   之前: +------------------------+------------------------+                | |
|   |         |  0xDEADBEEF            |    0xFFFFFFFF          |                | |
|   |         +------------------------+------------------------+                | |
|   |                                                                             | |
|   |   之后: +------------------------+------------------------+                | |
|   |         |  0x00000000  <-清零    |    0x00000000          |                | |
|   |         +------------------------+------------------------+                | |
|   |                                          ^                                  | |
|   |                                          +--- 低32位结果(溢出)              | |
|   |                                                                             | |
|   |   ⚠️  重要: 32 位操作会将高 32 位清零 (零扩展)!                             | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   Rust 代码常量:                                                                  |
|   +-----------------------------------------------------------------------------+ |
|   |  // crates/bpf-verifier-core/src/core/types.rs                              | |
|   |                                                                             | |
|   |  pub const BPF_ALU: u8 = 0x04;    // 32位算术运算类                         | |
|   |  pub const BPF_ALU64: u8 = 0x07;  // 64位算术运算类                         | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 内存访问指令详解 | Memory Instructions in Detail

```
+-----------------------------------------------------------------------------------+
|                             内存访问指令                                          |
|                          Memory Access Instructions                               |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                          加载指令 (Load)                                    | |
|   |                                                                             | |
|   |   语法: LDX{B|H|W|DW} dst, [src + offset]                                  | |
|   |   语义: dst = *(type *)(src + offset)                                      | |
|   |                                                                             | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |   |  指令   |    操作码      |           含义                         |    | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |   | LDXB    | 0x71           | dst = *(u8 *)(src + off)              |    | |
|   |   | LDXH    | 0x69           | dst = *(u16 *)(src + off)             |    | |
|   |   | LDXW    | 0x61           | dst = *(u32 *)(src + off)             |    | |
|   |   | LDXDW   | 0x79           | dst = *(u64 *)(src + off)             |    | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |                                                                             | |
|   |   符号扩展加载 (Signed Load):                                               | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |   | LDXSB   | 0x71 + sign    | dst = *(s8 *)(src + off)              |    | |
|   |   | LDXSH   | 0x69 + sign    | dst = *(s16 *)(src + off)             |    | |
|   |   | LDXSW   | 0x61 + sign    | dst = *(s32 *)(src + off)             |    | |
|   |   +---------+----------------+----------------------------------------+    | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                          存储指令 (Store)                                   | |
|   |                                                                             | |
|   |   语法: STX{B|H|W|DW} [dst + offset], src                                  | |
|   |   语义: *(type *)(dst + offset) = src                                      | |
|   |                                                                             | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |   |  指令   |    操作码      |           含义                         |    | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |   | STXB    | 0x73           | *(u8 *)(dst + off) = src              |    | |
|   |   | STXH    | 0x6b           | *(u16 *)(dst + off) = src             |    | |
|   |   | STXW    | 0x63           | *(u32 *)(dst + off) = src             |    | |
|   |   | STXDW   | 0x7b           | *(u64 *)(dst + off) = src             |    | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |                                                                             | |
|   |   存储立即数 (Store Immediate):                                             | |
|   |   +---------+----------------+----------------------------------------+    | |
|   |   | STB     | 0x72           | *(u8 *)(dst + off) = imm              |    | |
|   |   | STH     | 0x6a           | *(u16 *)(dst + off) = imm             |    | |
|   |   | STW     | 0x62           | *(u32 *)(dst + off) = imm             |    | |
|   |   | STDW    | 0x7a           | *(u64 *)(dst + off) = imm             |    | |
|   |   +---------+----------------+----------------------------------------+    | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   内存访问示例: 栈操作                                                            |
|   Memory Access Example: Stack Operations                                         |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                                                                             | |
|   |   程序: 把值存到栈上，再读回来                                              | |
|   |                                                                             | |
|   |   mov r1, 0x12345678     ; R1 = 0x12345678                                 | |
|   |   stxdw [r10 - 8], r1    ; 存储到栈 (R10-8)                                | |
|   |   ldxdw r2, [r10 - 8]    ; 从栈加载到 R2                                   | |
|   |   mov r0, r2             ; R0 = R2 = 0x12345678                            | |
|   |   exit                                                                      | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   栈内存布局:                                                                     |
|   Stack Memory Layout:                                                            |
|                                                                                   |
|         地址              内容                                                    |
|        +-----------------------------------------+                                |
|   高   |                                         |                                |
|   地   |  ...                                    |                                |
|   址   +-----------------------------------------+<--- R10 (栈帧指针)             |
|        |▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓|      (只读，不可修改)          |
|   R10-1+-----------------------------------------+                                |
|        |                                         |                                |
|   R10-8+-----------------------------------------+<--- stxdw 写入位置             |
|        |         0x12345678                      |      (8 字节)                  |
|        |   +---+---+---+---+---+---+---+---+    |                                |
|        |   |78 |56 |34 |12 |00 |00 |00 |00 |    |  小端序存储                    |
|        |   +---+---+---+---+---+---+---+---+    |                                |
|  R10-16+-----------------------------------------+                                |
|        |  ...                                    |                                |
|  R10-512                                         |                                |
|   低   +-----------------------------------------+<--- 栈底 (不可越过)            |
|   地   |▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓|                                |
|   址   +-----------------------------------------+                                |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 跳转指令详解 | Jump Instructions in Detail

```
+-----------------------------------------------------------------------------------+
|                              跳转指令                                             |
|                          Jump Instructions                                        |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                        条件跳转格式                                         | |
|   |                     Conditional Jump Format                                 | |
|   |                                                                             | |
|   |   语法: Jxx dst, src, +offset                                              | |
|   |   语义: if (dst OP src/imm) goto PC + 1 + offset                           | |
|   |                                                                             | |
|   |   注意: 跳转偏移是相对于 "下一条指令" 的位置!                               | |
|   |         offset=0 表示跳过 0 条，即继续执行下一条                            | |
|   |         offset=2 表示跳过 2 条指令                                          | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                        无符号条件跳转                                       | |
|   |                     Unsigned Conditional Jumps                              | |
|   |                                                                             | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |   | 助记符| 操作码 |              条件                                |    | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |   |  JEQ  | 0x1_   |  if (dst == src) goto +off                      |    | |
|   |   |  JNE  | 0x5_   |  if (dst != src) goto +off                      |    | |
|   |   |  JGT  | 0x2_   |  if (dst > src) goto +off   (无符号)            |    | |
|   |   |  JGE  | 0x3_   |  if (dst >= src) goto +off  (无符号)            |    | |
|   |   |  JLT  | 0xa_   |  if (dst < src) goto +off   (无符号)            |    | |
|   |   |  JLE  | 0xb_   |  if (dst <= src) goto +off  (无符号)            |    | |
|   |   |  JSET | 0x4_   |  if (dst & src) goto +off   (位测试)            |    | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                        有符号条件跳转                                       | |
|   |                      Signed Conditional Jumps                               | |
|   |                                                                             | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |   | 助记符| 操作码 |              条件                                |    | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |   | JSGT  | 0x6_   |  if (dst > src) goto +off   (有符号)            |    | |
|   |   | JSGE  | 0x7_   |  if (dst >= src) goto +off  (有符号)            |    | |
|   |   | JSLT  | 0xc_   |  if (dst < src) goto +off   (有符号)            |    | |
|   |   | JSLE  | 0xd_   |  if (dst <= src) goto +off  (有符号)            |    | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |                                                                             | |
|   |   有符号 vs 无符号的区别:                                                   | |
|   |   +-----------------------------------------------------------------------+ | |
|   |   |                                                                       | | |
|   |   |   假设 R1 = 0xFFFFFFFF (-1 有符号, 4294967295 无符号)                 | | |
|   |   |        R2 = 0x00000001 (1)                                            | | |
|   |   |                                                                       | | |
|   |   |   JGT R1, R2, +5   ; 无符号比较: 4294967295 > 1 ? 是! 跳转!          | | |
|   |   |   JSGT R1, R2, +5  ; 有符号比较: -1 > 1 ? 否! 不跳转!                | | |
|   |   |                                                                       | | |
|   |   +-----------------------------------------------------------------------+ | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                        控制流指令                                           | |
|   |                      Control Flow Instructions                              | |
|   |                                                                             | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |   | 助记符| 操作码 |              功能                                |    | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |   |  JA   | 0x05   |  无条件跳转: goto PC + 1 + off                  |    | |
|   |   |  CALL | 0x85   |  调用辅助函数: helper_id = imm                  |    | |
|   |   |  EXIT | 0x95   |  程序退出: return R0                            |    | |
|   |   +-------+--------+--------------------------------------------------+    | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   示例: 实现 if-else 结构                                                         |
|   Example: Implementing if-else Structure                                         |
|                                                                                   |
|   C 代码:                                                                         |
|   +-----------------------------------------------------------------------------+ |
|   |  if (r1 > 10) {                                                             | |
|   |      r0 = 1;      // then 分支                                             | |
|   |  } else {                                                                   | |
|   |      r0 = 0;      // else 分支                                             | |
|   |  }                                                                          | |
|   |  return r0;                                                                 | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   BPF 指令:                                                                       |
|   +----+------------------+----------------------------------------------------+  |
|   | #  | 指令              | 说明                                               |  |
|   +----+------------------+----------------------------------------------------+  |
|   | 0  | jgt r1, 10, +2   | if R1 > 10, 跳到指令 #3 (跳过2条)                 |  |
|   | 1  | mov r0, 0        | else 分支: R0 = 0                                  |  |
|   | 2  | ja +1            | 跳过 then 分支, 到指令 #4                          |  |
|   | 3  | mov r0, 1        | then 分支: R0 = 1                                  |  |
|   | 4  | exit             | 返回 R0                                            |  |
|   +----+------------------+----------------------------------------------------+  |
|                                                                                   |
|   控制流图:                                                                       |
|   Control Flow Graph:                                                             |
|                                                                                   |
|                     +-----------------------+                                     |
|                     |   #0: jgt r1, 10, +2  |                                     |
|                     |       (条件跳转)       |                                     |
|                     +-----------+-----------+                                     |
|                                 |                                                 |
|               +-----------------+-----------------+                               |
|               | R1 <= 10                R1 > 10   |                               |
|               v                                   v                               |
|    +-------------------+               +-------------------+                      |
|    |   #1: mov r0, 0   |               |   #3: mov r0, 1   |                      |
|    |   (else 分支)     |               |   (then 分支)     |                      |
|    +---------+---------+               +---------+---------+                      |
|              |                                   |                                |
|              v                                   |                                |
|    +-------------------+                         |                                |
|    |    #2: ja +1      |                         |                                |
|    |   (跳过 then)     |                         |                                |
|    +---------+---------+                         |                                |
|              |                                   |                                |
|              +---------------+-------------------+                                |
|                              v                                                    |
|                   +-------------------+                                           |
|                   |     #4: exit      |                                           |
|                   |    (返回 R0)      |                                           |
|                   +-------------------+                                           |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 辅助函数调用 | Helper Function Calls

```
+-----------------------------------------------------------------------------------+
|                            辅助函数 (Helper) 调用                                 |
|                          Helper Function Calls                                    |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   BPF 程序通过 CALL 指令调用内核提供的辅助函数:                                   |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                          CALL 指令格式                                      | |
|   |                                                                             | |
|   |   opcode = 0x85  (JMP class + CALL operation)                              | |
|   |   imm = helper function ID                                                 | |
|   |                                                                             | |
|   |   调用约定:                                                                 | |
|   |   +-----------------------------------------------------------------------+ | |
|   |   |                                                                       | | |
|   |   |   输入参数:  R1, R2, R3, R4, R5  (最多 5 个参数)                      | | |
|   |   |   返回值:    R0                                                        | | |
|   |   |   被破坏:    R1-R5 (调用后值不确定)                                   | | |
|   |   |   被保留:    R6-R9 (callee-saved, 调用后值不变)                       | | |
|   |   |                                                                       | | |
|   |   +-----------------------------------------------------------------------+ | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   常用辅助函数:                                                                   |
|   Common Helper Functions:                                                        |
|                                                                                   |
|   +--------+------------------------+----------------------------------------+   |
|   |  ID    |  函数名                 |  功能                                  |   |
|   +--------+------------------------+----------------------------------------+   |
|   |   1    | bpf_map_lookup_elem    | 在 Map 中查找键对应的值                |   |
|   |        |                        | R1=map, R2=&key -> R0=&value|NULL       |   |
|   +--------+------------------------+----------------------------------------+   |
|   |   2    | bpf_map_update_elem    | 更新 Map 中的键值对                    |   |
|   |        |                        | R1=map, R2=&key, R3=&val, R4=flags     |   |
|   +--------+------------------------+----------------------------------------+   |
|   |   3    | bpf_map_delete_elem    | 删除 Map 中的键                        |   |
|   |        |                        | R1=map, R2=&key                        |   |
|   +--------+------------------------+----------------------------------------+   |
|   |   4    | bpf_probe_read         | 安全地从内核内存读取                   |   |
|   |        |                        | R1=dst, R2=size, R3=src                |   |
|   +--------+------------------------+----------------------------------------+   |
|   |   5    | bpf_ktime_get_ns       | 获取当前时间 (纳秒)                    |   |
|   |        |                        | 无参数 -> R0=时间戳                     |   |
|   +--------+------------------------+----------------------------------------+   |
|   |   6    | bpf_trace_printk       | 打印调试信息到 trace_pipe              |   |
|   |        |                        | R1=fmt, R2=len, R3-R5=参数             |   |
|   +--------+------------------------+----------------------------------------+   |
|   |  14    | bpf_get_current_       | 获取当前进程的 PID 和 TGID             |   |
|   |        | pid_tgid               | 无参数 -> R0=((u64)tgid<<32)|pid        |   |
|   +--------+------------------------+----------------------------------------+   |
|   |  15    | bpf_get_current_       | 获取当前用户的 UID 和 GID              |   |
|   |        | uid_gid                | 无参数 -> R0=((u64)gid<<32)|uid         |   |
|   +--------+------------------------+----------------------------------------+   |
|   |  16    | bpf_get_current_comm   | 获取当前进程名                         |   |
|   |        |                        | R1=buf, R2=size -> R0=0|error           |   |
|   +--------+------------------------+----------------------------------------+   |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   示例: 使用 bpf_map_lookup_elem                                                  |
|   Example: Using bpf_map_lookup_elem                                              |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |  // 在栈上准备 key                                                          | |
|   |  mov r1, 42                   ; key 值 = 42                                 | |
|   |  stxdw [r10 - 8], r1          ; 存储到栈上                                  | |
|   |                                                                             | |
|   |  // 准备参数并调用                                                          | |
|   |  ld_map_fd r1, map_fd         ; R1 = map 文件描述符                         | |
|   |  mov r2, r10                  ; R2 = 栈指针                                 | |
|   |  add r2, -8                   ; R2 = &key (栈上的 key 地址)                 | |
|   |  call 1                       ; 调用 bpf_map_lookup_elem                    | |
|   |                                                                             | |
|   |  // 检查返回值                                                              | |
|   |  jeq r0, 0, not_found         ; 如果返回 NULL，跳转到 not_found             | |
|   |  ldxdw r1, [r0 + 0]           ; 读取 value                                  | |
|   |  // ...使用 value...                                                        | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   调用过程可视化:                                                                 |
|                                                                                   |
|   +----------------+                                                              |
|   |    调用前       |                                                              |
|   |                |                                                              |
|   |  R1 = &map     |  -----------------------------------------+                  |
|   |  R2 = &key     |  -------------+                          |                  |
|   |  R3 = ?        |               |                          |                  |
|   |  R4 = ?        |               v                          v                  |
|   |  R5 = ?        |          +---------+               +----------+             |
|   +----------------+          |   key   |               |   Map    |             |
|                               |   42    |               |  {...}   |             |
|            |                  +---------+               +----------+             |
|            |                       栈                       内核                 |
|            v                                                                      |
|   +----------------+                                                              |
|   |   call 1       |   --------->   bpf_map_lookup_elem(map, &key)               |
|   +----------------+                                                              |
|            |                                                                      |
|            v                                                                      |
|   +----------------+                                                              |
|   |    调用后       |                                                              |
|   |                |                                                              |
|   |  R0 = &value   |  -------------+                                              |
|   |  或 NULL       |               |                                              |
|   |  R1-R5 = ?     |               v                                              |
|   |  R6-R9 = 不变  |          +---------+                                         |
|   +----------------+          |  value  |  Map 中 key=42 对应的值                 |
|                               |  {...}  |                                         |
|                               +---------+                                         |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 特殊指令 | Special Instructions

```
+-----------------------------------------------------------------------------------+
|                              特殊指令                                             |
|                          Special Instructions                                     |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                      LD_IMM64 (加载64位立即数)                              | |
|   |                                                                             | |
|   |   问题: 一条 BPF 指令只有 32 位立即数字段，如何加载 64 位常量？             | |
|   |                                                                             | |
|   |   解决方案: 使用两条连续指令编码一个 64 位值                                | |
|   |                                                                             | |
|   |   +-----------------------------------------------------------------------+ | |
|   |   |                                                                       | | |
|   |   |   第一条指令 (8 字节):                                                | | |
|   |   |   +--------+--------+--------+------------------------+              | | |
|   |   |   |  0x18  |dst|src | 0x0000 |     低 32 位 (imm)     |              | | |
|   |   |   | opcode |        |        |                        |              | | |
|   |   |   +--------+--------+--------+------------------------+              | | |
|   |   |                                                                       | | |
|   |   |   第二条指令 (8 字节, 伪指令):                                        | | |
|   |   |   +--------+--------+--------+------------------------+              | | |
|   |   |   |  0x00  |  0x00  | 0x0000 |     高 32 位 (imm)     |              | | |
|   |   |   | 不使用 |        |        |                        |              | | |
|   |   |   +--------+--------+--------+------------------------+              | | |
|   |   |                                                                       | | |
|   |   |   完整的 64 位值 = (高32位 << 32) | 低32位                            | | |
|   |   |                                                                       | | |
|   |   +-----------------------------------------------------------------------+ | |
|   |                                                                             | |
|   |   用途:                                                                     | |
|   |   • 加载 Map 文件描述符 (ld_map_fd)                                        | |
|   |   • 加载 64 位地址或大常量                                                 | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                      字节序转换 (Endianness Conversion)                     | |
|   |                                                                             | |
|   |   BPF 运行在小端序 (little-endian) 系统上，但网络协议使用大端序。          | |
|   |                                                                             | |
|   |   +-----------+--------+----------------------------------------------+    | |
|   |   |   指令    | 操作码 |              功能                            |    | |
|   |   +-----------+--------+----------------------------------------------+    | |
|   |   |  le16     | 0xd4   | 16位小端转换 (在大端系统上)                  |    | |
|   |   |  le32     | 0xd4   | 32位小端转换                                 |    | |
|   |   |  le64     | 0xd4   | 64位小端转换                                 |    | |
|   |   |  be16     | 0xdc   | 16位大端转换 (网络字节序)                    |    | |
|   |   |  be32     | 0xdc   | 32位大端转换                                 |    | |
|   |   |  be64     | 0xdc   | 64位大端转换                                 |    | |
|   |   +-----------+--------+----------------------------------------------+    | |
|   |                                                                             | |
|   |   示例:                                                                     | |
|   |   +-----------------------------------------------------------------------+ | |
|   |   |  // 将主机字节序转换为网络字节序 (大端)                               | | |
|   |   |  ldxh r1, [r2 + 0]     ; 加载 16 位值 (主机序)                        | | |
|   |   |  be16 r1               ; 转换为大端 (网络序)                          | | |
|   |   |  stxh [r3 + 0], r1     ; 存储转换后的值                               | | |
|   |   +-----------------------------------------------------------------------+ | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 完整程序示例 | Complete Program Example

```
+-----------------------------------------------------------------------------------+
|                          完整 BPF 程序示例                                        |
|                      Complete BPF Program Example                                 |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   目标: 计算 100 + 200，并返回结果                                                |
|   Goal: Calculate 100 + 200 and return the result                                 |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                           程序代码                                          | |
|   |                                                                             | |
|   |   +----+------------------+--------------------------------------------+   | |
|   |   | #  | 指令              | 二进制编码 (十六进制)                      |   | |
|   |   +----+------------------+--------------------------------------------+   | |
|   |   | 0  | mov r1, 100      | b7 01 00 00 64 00 00 00                   |   | |
|   |   | 1  | mov r2, 200      | b7 02 00 00 c8 00 00 00                   |   | |
|   |   | 2  | add r1, r2       | 0f 21 00 00 00 00 00 00                   |   | |
|   |   | 3  | mov r0, r1       | bf 10 00 00 00 00 00 00                   |   | |
|   |   | 4  | exit             | 95 00 00 00 00 00 00 00                   |   | |
|   |   +----+------------------+--------------------------------------------+   | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   执行过程可视化:                                                                 |
|   Execution Visualization:                                                        |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |                                                                             | |
|   |   初始状态 (程序开始):                                                      | |
|   |   +----+----+----+----+----+----+----+----+----+----+------+               | |
|   |   | R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10  |               | |
|   |   | ?? |CTX | ?? | ?? | ?? | ?? | ?? | ?? | ?? | ?? | SP   |               | |
|   |   +----+----+----+----+----+----+----+----+----+----+------+               | |
|   |                     ^                                     ^                 | |
|   |                     |                                     |                 | |
|   |              程序上下文指针                          栈帧指针               | |
|   |                                                                             | |
|   |   ------------------------------------------------------------------------- | |
|   |                                                                             | |
|   |   指令 #0: mov r1, 100                                                      | |
|   |   +----+----+----+----+----+----+----+----+----+----+------+               | |
|   |   | R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10  |               | |
|   |   | ?? |100 | ?? | ?? | ?? | ?? | ?? | ?? | ?? | ?? | SP   |               | |
|   |   +----+-^--+----+----+----+----+----+----+----+----+------+               | |
|   |          |                                                                  | |
|   |          +-- 写入 100                                                       | |
|   |                                                                             | |
|   |   ------------------------------------------------------------------------- | |
|   |                                                                             | |
|   |   指令 #1: mov r2, 200                                                      | |
|   |   +----+----+----+----+----+----+----+----+----+----+------+               | |
|   |   | R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10  |               | |
|   |   | ?? |100 |200 | ?? | ?? | ?? | ?? | ?? | ?? | ?? | SP   |               | |
|   |   +----+----+-^--+----+----+----+----+----+----+----+------+               | |
|   |               |                                                             | |
|   |               +-- 写入 200                                                  | |
|   |                                                                             | |
|   |   ------------------------------------------------------------------------- | |
|   |                                                                             | |
|   |   指令 #2: add r1, r2  (R1 = R1 + R2)                                       | |
|   |   +----+----+----+----+----+----+----+----+----+----+------+               | |
|   |   | R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10  |               | |
|   |   | ?? |300 |200 | ?? | ?? | ?? | ?? | ?? | ?? | ?? | SP   |               | |
|   |   +----+-^--+----+----+----+----+----+----+----+----+------+               | |
|   |          |                                                                  | |
|   |          +-- 100 + 200 = 300                                                | |
|   |                                                                             | |
|   |   ------------------------------------------------------------------------- | |
|   |                                                                             | |
|   |   指令 #3: mov r0, r1  (R0 = R1)                                            | |
|   |   +----+----+----+----+----+----+----+----+----+----+------+               | |
|   |   | R0 | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10  |               | |
|   |   |300 |300 |200 | ?? | ?? | ?? | ?? | ?? | ?? | ?? | SP   |               | |
|   |   +-^--+----+----+----+----+----+----+----+----+----+------+               | |
|   |     |                                                                       | |
|   |     +-- 设置返回值                                                          | |
|   |                                                                             | |
|   |   ------------------------------------------------------------------------- | |
|   |                                                                             | |
|   |   指令 #4: exit                                                             | |
|   |                                                                             | |
|   |   程序结束，返回 R0 = 300  ✓                                                | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   Rust 代码实现:                                                                  |
|                                                                                   |
|   +-----------------------------------------------------------------------------+ |
|   |  // 文件: crates/bpf-verifier-core/src/core/insn.rs                         | |
|   |                                                                             | |
|   |  use bpf_verifier_core::core::insn::BpfInsn;                               | |
|   |                                                                             | |
|   |  fn create_add_program() -> Vec<BpfInsn> {                                 | |
|   |      vec![                                                                  | |
|   |          // 指令 0: R1 = 100                                               | |
|   |          BpfInsn::mov64_imm(1, 100),                                       | |
|   |                                                                             | |
|   |          // 指令 1: R2 = 200                                               | |
|   |          BpfInsn::mov64_imm(2, 200),                                       | |
|   |                                                                             | |
|   |          // 指令 2: R1 = R1 + R2                                           | |
|   |          BpfInsn::add64_reg(1, 2),                                         | |
|   |                                                                             | |
|   |          // 指令 3: R0 = R1 (设置返回值)                                   | |
|   |          BpfInsn::mov64_reg(0, 1),                                         | |
|   |                                                                             | |
|   |          // 指令 4: 退出程序                                               | |
|   |          BpfInsn::exit(),                                                  | |
|   |      ]                                                                      | |
|   |  }                                                                          | |
|   |                                                                             | |
|   +-----------------------------------------------------------------------------+ |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 章节小结 | Chapter Summary

```
+-----------------------------------------------------------------------------------+
|                                本章要点                                           |
|                            Key Takeaways                                          |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   你现在了解了:                                                                   |
|   ------------------------------------------------------------------------------- |
|                                                                                   |
|   1. BPF 指令格式                                                                 |
|      • 每条指令 64 位 (8 字节)                                                    |
|      • 由 opcode、dst、src、offset、immediate 组成                               |
|      • opcode 编码指令类别和操作类型                                              |
|                                                                                   |
|   2. 指令类别                                                                     |
|      • ALU: 算术和逻辑运算 (add、sub、and、or...)                                |
|      • MEM: 内存加载和存储 (ldx、stx)                                            |
|      • JMP: 跳转和控制流 (jeq、jne、call、exit)                                  |
|      • ATOMIC: 原子操作 (xadd、cmpxchg)                                          |
|                                                                                   |
|   3. 32位 vs 64位                                                                 |
|      • ALU (class 0x04): 32位操作，高32位清零                                    |
|      • ALU64 (class 0x07): 完整64位操作                                          |
|                                                                                   |
|   4. 内存访问                                                                     |
|      • 支持 1/2/4/8 字节访问                                                     |
|      • 栈通过 R10 (只读) 负偏移访问                                              |
|      • 有符号和无符号加载                                                         |
|                                                                                   |
|   5. 辅助函数                                                                     |
|      • CALL 指令调用内核辅助函数                                                 |
|      • R1-R5 传参，R0 返回值                                                     |
|      • R6-R9 跨调用保留                                                          |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 练习 | Exercises

```
+-----------------------------------------------------------------------------------+
|                                 练习题                                            |
|                                Exercises                                          |
+-----------------------------------------------------------------------------------+
|                                                                                   |
|   1. 编写程序: 计算 (10 - 3) * 4                                                  |
|      Write a program to calculate (10 - 3) * 4                                    |
|                                                                                   |
|   2. 编写程序: 如果 R1 > 100，返回 1；否则返回 0                                  |
|      If R1 > 100, return 1; otherwise return 0                                    |
|                                                                                   |
|   3. 分析这段代码会发生什么？验证器会接受吗？                                     |
|      Analyze: What happens? Will the verifier accept it?                          |
|                                                                                   |
|      +----------------------------------------+                                   |
|      |   mov r1, 10                           |                                   |
|      |   loop:                                |                                   |
|      |     sub r1, 1                          |                                   |
|      |     jne r1, 0, loop                    |                                   |
|      |     exit                               |                                   |
|      +----------------------------------------+                                   |
|                                                                                   |
|   4. 解码指令: 0x85 0x00 0x00 0x00 0x01 0x00 0x00 0x00                            |
|      Decode the instruction above                                                 |
|                                                                                   |
|   5. 写出 "r0 = r0 + r1" 的二进制编码                                             |
|      Write the binary encoding for "r0 = r0 + r1"                                 |
|                                                                                   |
+-----------------------------------------------------------------------------------+
```

---

## 项目代码对照 | Code Reference

| 内容 | 文件位置 |
|------|----------|
| 指令结构定义 | `crates/bpf-verifier-core/src/core/insn.rs` |
| 指令常量 (opcode) | `crates/bpf-verifier-core/src/core/types.rs` |
| 反汇编器 | `crates/bpf-verifier-core/src/core/disasm.rs` |
| 指令验证 | `crates/bpf-verifier-core/src/core/insn_verify.rs` |

---

[⬅️ 上一章：什么是 BPF？](01-what-is-bpf.md) | [返回目录](00-introduction.md) | [下一章：为什么需要验证器？ ➡️](03-why-verifier.md)
