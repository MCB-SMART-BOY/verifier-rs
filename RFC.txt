Subject: [RFC] Rust implementation of BPF verifier

To: rust-for-linux@vger.kernel.org
Cc: bpf@vger.kernel.org
Cc: Alexei Starovoitov <ast@kernel.org>
Cc: Daniel Borkmann <daniel@iogearbox.net>
Cc: Miguel Ojeda <ojeda@kernel.org>
Cc: Andrii Nakryiko <andrii@kernel.org>

Hi everyone,

With Rust now officially adopted as a core language in the Linux kernel
(as decided at the 2025 Kernel Maintainer Summit), I would like to
propose a Rust implementation of the BPF verifier for consideration.

== Motivation ==

The BPF verifier (kernel/bpf/verifier.c) is one of the most complex
subsystems in the Linux kernel, comprising approximately 30,000 lines
of intricate C code. Given Rust's safety guarantees and its official
status in the kernel, a Rust implementation could provide:

1. **Compile-time safety**: Rust's ownership model catches memory
   safety bugs at compile time that would be runtime errors in C.

2. **Type-safe state tracking**: Register states and bounds tracking
   benefit significantly from Rust's strong type system and enums.

3. **Reduced attack surface**: The verifier is security-critical;
   Rust's strict aliasing rules reduce potential vulnerabilities.

4. **Maintainability**: Pattern matching and traits make the complex
   state machines in the verifier more readable.

== Implementation Status ==

The implementation is feature-complete (~78,000 lines including tests):

  - Full register state tracking (R0-R10)
  - Tnum (tracked number) arithmetic for precise bounds
  - 211 BPF helper function signatures
  - 85+ kernel function (kfunc) definitions (synced with 6.12)
  - State pruning with hash-indexed equivalence checking
  - Reference tracking (locks, RCU, acquired references)
  - IRQ flag state tracking
  - Memory verification (stack, packet, context, map, arena)
  - Spectre v1/v4 mitigation checks
  - 300+ unit tests

Technical characteristics:
  - `#![no_std]` compatible
  - Uses only `alloc` crate (KVec, KBox in kernel)
  - GPL-2.0-only license
  - Pure Rust - no C glue code required (Linux 6.12+ style)

== Integration Approach ==

Using the native `kernel::Module` trait (no C glue needed):

```rust
use kernel::prelude::*;

module! {
    type: RustBpfVerifier,
    name: "rust_bpf_verifier",
    license: "GPL",
}

struct RustBpfVerifier { /* state */ }

impl kernel::Module for RustBpfVerifier {
    fn init(_module: &'static ThisModule) -> Result<Self> {
        pr_info!("Rust BPF verifier loaded\n");
        Ok(Self { })
    }
}
```

The verifier would hook into `bpf_check()` via:
  - CONFIG_BPF_VERIFIER_RUST=y to enable
  - Runtime sysctl to switch between C and Rust

== Proposed Phases ==

Phase 1: RFC and design review (this email)
  - Gather feedback on approach
  - Discuss integration with BPF maintainers

Phase 2: Kernel abstractions
  - Add necessary kernel crate APIs for BPF
  - Integrate with existing BPF infrastructure

Phase 3: Validation
  - Run kernel BPF selftests with Rust verifier
  - Performance comparison with C verifier
  - Security audit

Phase 4: Gradual adoption
  - Initially disabled by default (CONFIG=n)
  - Runtime switchable for testing
  - Production hardening

== Questions for the Community ==

1. With Rust now official, is there appetite for a Rust BPF verifier?

2. Should the Rust verifier:
   a) Eventually replace the C implementation?
   b) Coexist as a selectable alternative?
   c) Be used for specific verification passes only?

3. What kernel crate APIs would need to be added for BPF integration?

4. What validation/benchmarks are required for acceptance?

== Repository ==

The code is available at:
  https://github.com/MCB-SMART-BOY/verifier-rs

I welcome any feedback, questions, or concerns.

Best regards,
[Your Name]
[Your Email]

---
Note: Before sending:
1. Replace [Your Name] and [Your Email]
2. Subscribe to rust-for-linux@vger.kernel.org first
3. Use `git send-email` for proper formatting
